<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>My Project: .ASS File formats</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(14)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">.ASS <a class="el" href="class_file.html">File</a> formats </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="over"></a>
Overview</h1>
<p><a class="el" href="class_assimp.html">Assimp</a> provides its own interchange format, which is intended to applications which need to serialize 3D-models and to reload them quickly. <a class="el" href="class_assimp.html">Assimp</a>'s file formats are designed to be read by <a class="el" href="class_assimp.html">Assimp</a> itself. They encode additional information needed by <a class="el" href="class_assimp.html">Assimp</a> to optimize its postprocessing pipeline. If you once apply specific steps to a scene, then save it and reread it from an ASS format using the same post processing settings, they won't be executed again.</p>
<p>The format comes in two flavours: XML and binary - both of them hold a complete dump of the '<a class="el" href="structai_scene.html">aiScene</a>' data structure returned by the APIs. The focus for the binary format (<code>.assbin</code>) is fast loading. Optional deflate compression helps reduce file size. The XML flavour, <code>.assxml</code> or simply .xml, is just a plain-to-xml conversion of <a class="el" href="structai_scene.html">aiScene</a>.</p>
<p>ASSBIN is <a class="el" href="class_assimp.html">Assimp</a>'s binary interchange format. assimp_cmd (<code>&lt;root&gt;/tools/assimp_cmd</code>) is able to write it and the core library provides a loader for it.</p>
<h1><a class="anchor" id="assxml"></a>
XML File format</h1>
<p>The format is pretty much self-explanatory due to its similarity to the in-memory <a class="el" href="structai_scene.html">aiScene</a> structure. <a class="el" href="struct_with.html">With</a> few exceptions, C structures are wrapped in XML elements.</p>
<p>The DTD for ASSXML can be found in <code>&lt;root&gt;/doc/AssXML_Scheme.xml</code>. Or have look at the output files generated by assimp_cmd.</p>
<h1><a class="anchor" id="assbin"></a>
Binary file format</h1>
<p>The ASSBIN file format is composed of chunks to represent the hierarchical <a class="el" href="structai_scene.html">aiScene</a> data structure. This makes the format extensible and allows backward-compatibility with future data structure versions. The <code>&lt;root&gt;/code/assbin_chunks.h</code> header contains some magic constants for use by stand-alone ASSBIN loaders. Also, <a class="el" href="class_assimp.html">Assimp</a>'s own file writer can be found in <code>&lt;root&gt;/tools/assimp_cmd/WriteDumb.cpp</code> (yes, the 'b' is no typo ...).</p>
<pre class="fragment">-------------------------------------------------------------------------------
1. File structure:
-------------------------------------------------------------------------------

----------------------
| Header (500 bytes) |
----------------------
| Variable chunks    |
----------------------

-------------------------------------------------------------------------------
2. Definitions:
-------------------------------------------------------------------------------

integer is four bytes wide, stored in little-endian byte order.
short   is two bytes wide, stored in little-endian byte order.
byte    is a single byte.
string  is an integer n followed by n UTF-8 characters, not terminated by zero
float   is an IEEE 754 single-precision floating-point value 
double  is an IEEE 754 double-precision floating-point value 
t[n]    is an array of n elements of type t

-------------------------------------------------------------------------------
2. Header:
-------------------------------------------------------------------------------

byte[44]    Magic identification string for ASSBIN files.
                'ASSIMP.binary'

integer     Major version of the Assimp library which wrote the file
integer     Minor version of the Assimp library which wrote the file
                match these against ASSBIN_VERSION_MAJOR and ASSBIN_VERSION_MINOR

integer     SVN revision of the Assimp library (intended for our internal
            debugging - if you write Ass files from your own APPs, set this value to 0.
integer     Assimp compile flags

short       0 for normal files, 1 for shortened dumps for regression tests 
                these should have the file extension assbin.regress

short       1 if the data after the header is compressed with the DEFLATE algorithm,
            0 for uncompressed files.
                   For compressed files, the first integer after the header is
                   always the uncompressed data size
                
byte[256]   Zero-terminated source file name, UTF-8
byte[128]   Zero-terminated command line parameters passed to assimp_cmd, UTF-8 

byte[64]    Reserved for future use
---&gt; Total length: 512 bytes

-------------------------------------------------------------------------------
3. Chunks:
-------------------------------------------------------------------------------

integer     Magic chunk ID (ASSBIN_CHUNK_XXX)
integer     Chunk data length, in bytes 
                (unknown chunks are possible, a good reader skips over them)

byte[n]     length-of-chunk bytes of data, depending on the chunk type

Chunks can contain nested chunks. Nested chunks are ALWAYS at the end of the chunk,
their size is included in length-of-chunk.

The chunk layout for all ASSIMP data structures is derived from their C declarations.
The general 'rule' to get from Assimp headers to the serialized layout is:

   1. POD members (i.e. aiMesh::mPrimitiveTypes, aiMesh::mNumVertices), 
        in order of declaration.

   2. Array-members (aiMesh::mFaces, aiMesh::mVertices, aiBone::mWeights), 
        in order of declaration.

   2. Object array members (i.e aiMesh::mBones, aiScene::mMeshes) are stored in 
      subchunks directly following the data written in 1.) and 2.)


    Of course, there are some exceptions to this general order:

[[aiScene]]

   - The root node holding the scene structure is naturally stored in
     a ASSBIN_CHUNK_AINODE subchunk following 1.) and 2.) (which is 
     empty for aiScene).

[[aiMesh]]

   - mTextureCoords and mNumUVComponents are serialized as follows:

   [number of used uv channels times]
       integer mNumUVComponents[n]
       float mTextureCoords[n][mNumUVComponents[n]]

       -&gt; more than AI_MAX_TEXCOORD_CHANNELS can be stored. This allows Assimp 
       builds with different settings for AI_MAX_TEXCOORD_CHANNELS to exchange
       data. Unlike the in-memory format, only the used components of the 
       UV coordinates are written to disk. If mNumUVComponents[0] is 1, the
       corresponding mTextureCoords array consists of mNumTextureCoords*1 
       single floats.

   - The array member block of aiMesh is prefixed with an integer that specifies 
     the kinds of vertex components actually present in the mesh. This is a 
     bitwise combination of the ASSBIN_MESH_HAS_xxx constants.

[[aiFace]]

   - mNumIndices is stored as short
   - mIndices are written as short, if aiMesh::mNumVertices&lt;65536

[[aiNode]]

   - mParent is omitted

[[aiLight]]

   - mAttenuationXXX not written if aiLight::mType == aiLightSource_DIRECTIONAL
   - mAngleXXX not written if aiLight::mType != aiLightSource_SPOT

[[aiMaterial]]

   - mNumAllocated is omitted, for obvious reasons :-)</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 17 2014 12:19:50 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
