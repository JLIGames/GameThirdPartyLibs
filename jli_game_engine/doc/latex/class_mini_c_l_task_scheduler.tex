\hypertarget{class_mini_c_l_task_scheduler}{\section{Mini\+C\+L\+Task\+Scheduler Class Reference}
\label{class_mini_c_l_task_scheduler}\index{Mini\+C\+L\+Task\+Scheduler@{Mini\+C\+L\+Task\+Scheduler}}
}


{\ttfamily \#include $<$Mini\+C\+L\+Task\+Scheduler.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_mini_c_l_task_scheduler_a3fd2147fd33425ec936e49a898a4f6d0}{{\bfseries Mini\+C\+L\+Task\+Scheduler} (\hyperlink{classbt_thread_support_interface}{bt\+Thread\+Support\+Interface} $\ast$thread\+Interface, int max\+Num\+Outstanding\+Tasks)}\label{class_mini_c_l_task_scheduler_a3fd2147fd33425ec936e49a898a4f6d0}

\item 
\hypertarget{class_mini_c_l_task_scheduler_ae3dbcee1e36753aac47327d035560f10}{void \hyperlink{class_mini_c_l_task_scheduler_ae3dbcee1e36753aac47327d035560f10}{initialize} ()}\label{class_mini_c_l_task_scheduler_ae3dbcee1e36753aac47327d035560f10}

\begin{DoxyCompactList}\small\item\em call initialize in the beginning of the frame, before add\+Collision\+Pair\+To\+Task \end{DoxyCompactList}\item 
\hypertarget{class_mini_c_l_task_scheduler_accd5680fa809616919d83df8e959cb90}{void {\bfseries issue\+Task} (int first\+Work\+Unit, int last\+Work\+Unit, \hyperlink{struct_mini_c_l_kernel}{Mini\+C\+L\+Kernel} $\ast$kernel)}\label{class_mini_c_l_task_scheduler_accd5680fa809616919d83df8e959cb90}

\item 
\hypertarget{class_mini_c_l_task_scheduler_aaaaefcab8688c6c73792b9786f700873}{void \hyperlink{class_mini_c_l_task_scheduler_aaaaefcab8688c6c73792b9786f700873}{flush} ()}\label{class_mini_c_l_task_scheduler_aaaaefcab8688c6c73792b9786f700873}

\begin{DoxyCompactList}\small\item\em call flush to submit potential outstanding work to S\+P\+Us and wait for all involved S\+P\+Us to be finished \end{DoxyCompactList}\item 
\hypertarget{class_mini_c_l_task_scheduler_a9576eb22445a68bc9cf1ca0501b974f0}{class \hyperlink{classbt_thread_support_interface}{bt\+Thread\+Support\+Interface} $\ast$ {\bfseries get\+Thread\+Support\+Interface} ()}\label{class_mini_c_l_task_scheduler_a9576eb22445a68bc9cf1ca0501b974f0}

\item 
\hypertarget{class_mini_c_l_task_scheduler_a4046f4cd389d0b7ba023057c1a3dc2b6}{int {\bfseries find\+Program\+Command\+Id\+By\+Name} (const char $\ast$program\+Name) const }\label{class_mini_c_l_task_scheduler_a4046f4cd389d0b7ba023057c1a3dc2b6}

\item 
\hypertarget{class_mini_c_l_task_scheduler_a4e20aef39d0ac9c938d1e2e7f46e9b2d}{int {\bfseries get\+Max\+Num\+Outstanding\+Tasks} () const }\label{class_mini_c_l_task_scheduler_a4e20aef39d0ac9c938d1e2e7f46e9b2d}

\item 
\hypertarget{class_mini_c_l_task_scheduler_aeba8cfc17be247623d84e56f735baf0c}{void {\bfseries register\+Kernel} (\hyperlink{struct_mini_c_l_kernel}{Mini\+C\+L\+Kernel} $\ast$kernel)}\label{class_mini_c_l_task_scheduler_aeba8cfc17be247623d84e56f735baf0c}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{class_mini_c_l_task_scheduler}{Mini\+C\+L\+Task\+Scheduler} handles S\+P\+U processing of collision pairs. When P\+P\+U issues a task, it will look for completed task buffers P\+P\+U will do postprocessing, dependent on workunit output (not likely) 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
bullet/bullet-\/2.\+82-\/r2704/src/\+Mini\+C\+L/Mini\+C\+L\+Task\+Scheduler.\+h\item 
bullet/bullet-\/2.\+82-\/r2704/src/\+Mini\+C\+L/Mini\+C\+L\+Task\+Scheduler.\+cpp\end{DoxyCompactItemize}
