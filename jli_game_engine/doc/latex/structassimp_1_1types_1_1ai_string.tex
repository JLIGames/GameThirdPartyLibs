\hypertarget{structassimp_1_1types_1_1ai_string}{\section{assimp\+:\+:types\+:\+:ai\+String Struct Reference}
\label{structassimp_1_1types_1_1ai_string}\index{assimp\+::types\+::ai\+String@{assimp\+::types\+::ai\+String}}
}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t \hyperlink{structassimp_1_1types_1_1ai_string_ae92dc7402798c16a0543f9a9fc7ea2ac}{length}
\item 
char \hyperlink{structassimp_1_1types_1_1ai_string_afe06048e3e72c3b60edb4810c145d2da}{data} \mbox{[}\hyperlink{namespaceassimp_1_1types_a43a64bf6b45fdc2376b2d8baa2b275f4}{M\+A\+X\+L\+E\+N}\mbox{]}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Represents an U\+T\+F-\/8 string, zero byte terminated.

The length of such a string is limited to {\ttfamily M\+A\+X\+L\+E\+N} bytes (excluding the terminal \textbackslash{}0).

The character set of an \hyperlink{structassimp_1_1types_1_1ai_string}{ai\+String} is explicitly defined to be U\+T\+F-\/8. This Unicode transformation was chosen in the belief that most strings in 3d model files are limited to A\+S\+C\+I\+I characters, thus the character set needed to be A\+S\+C\+I\+I compatible.

Most text file loaders provide proper Unicode input file handling, special unicode characters are correctly transcoded to U\+T\+F-\/8 and are kept throughout the libraries' import pipeline.

For most applications, it will be absolutely sufficient to interpret the \hyperlink{structassimp_1_1types_1_1ai_string}{ai\+String} as A\+S\+C\+I\+I data and work with it as one would work with a plain char\mbox{[}\mbox{]}.

To access an \hyperlink{structassimp_1_1types_1_1ai_string}{ai\+String} from D you might want to use something like the \subsubsection*{following piece of code\+: }

char\mbox{[}\mbox{]} import\+Ai\+String( ai\+String$\ast$ s ) \{ return s.\+data\mbox{[} 0 .. s.\+length \mbox{]}; \subsubsection*{\} }

\subsection{Member Data Documentation}
\hypertarget{structassimp_1_1types_1_1ai_string_afe06048e3e72c3b60edb4810c145d2da}{\index{assimp\+::types\+::ai\+String@{assimp\+::types\+::ai\+String}!data@{data}}
\index{data@{data}!assimp\+::types\+::ai\+String@{assimp\+::types\+::ai\+String}}
\subsubsection[{data}]{\setlength{\rightskip}{0pt plus 5cm}char assimp\+::types\+::ai\+String\+::data\mbox{[}{\bf M\+A\+X\+L\+E\+N}\mbox{]}}}\label{structassimp_1_1types_1_1ai_string_afe06048e3e72c3b60edb4810c145d2da}
String buffer.

Size limit is {\ttfamily M\+A\+X\+L\+E\+N}. \hypertarget{structassimp_1_1types_1_1ai_string_ae92dc7402798c16a0543f9a9fc7ea2ac}{\index{assimp\+::types\+::ai\+String@{assimp\+::types\+::ai\+String}!length@{length}}
\index{length@{length}!assimp\+::types\+::ai\+String@{assimp\+::types\+::ai\+String}}
\subsubsection[{length}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t assimp\+::types\+::ai\+String\+::length}}\label{structassimp_1_1types_1_1ai_string_ae92dc7402798c16a0543f9a9fc7ea2ac}
Length of the string (excluding the terminal \textbackslash{}0).

This is {\itshape not} the logical length of strings containing U\+T\+F-\/8 multibyte sequences, but the number of bytes from the beginning of the string to its end. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
assimp/assimp-\/3.\+1.\+1/port/d\+Assimp/assimp/types.\+d\end{DoxyCompactItemize}
