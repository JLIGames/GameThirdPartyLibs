\hypertarget{namespace_assimp}{\section{Assimp Namespace Reference}
\label{namespace_assimp}\index{Assimp@{Assimp}}
}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespace_assimp_1_1_s_t_e_p}{S\+T\+E\+P}
\begin{DoxyCompactList}\small\item\em I\+F\+C. \end{DoxyCompactList}\item 
package \hyperlink{namespace_assimp_1_1_viewer}{Viewer}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class_assimp_1_1_a_c3_d_importer}{A\+C3\+D\+Importer}
\item 
class \hyperlink{class_assimp_1_1_a_s_e_importer}{A\+S\+E\+Importer}
\item 
struct \hyperlink{struct_assimp_1_1_attachment_info}{Attachment\+Info}
\begin{DoxyCompactList}\small\item\em Helper data structure for \hyperlink{class_assimp_1_1_scene_combiner}{Scene\+Combiner}. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_b3_d_importer}{B3\+D\+Importer}
\item 
class \hyperlink{class_assimp_1_1_base_importer}{Base\+Importer}
\item 
class \hyperlink{class_assimp_1_1_base_process}{Base\+Process}
\item 
struct \hyperlink{struct_assimp_1_1_batch_data}{Batch\+Data}
\item 
class \hyperlink{class_assimp_1_1_batch_loader}{Batch\+Loader}
\item 
class \hyperlink{class_assimp_1_1_bitmap}{Bitmap}
\item 
class \hyperlink{class_assimp_1_1_blender_b_mesh_converter}{Blender\+B\+Mesh\+Converter}
\item 
class \hyperlink{class_assimp_1_1_blender_importer}{Blender\+Importer}
\item 
class \hyperlink{class_assimp_1_1_blender_tessellator_p2_t}{Blender\+Tessellator\+P2\+T}
\item 
class \hyperlink{class_assimp_1_1_blob_i_o_stream}{Blob\+I\+O\+Stream}
\item 
class \hyperlink{class_assimp_1_1_blob_i_o_system}{Blob\+I\+O\+System}
\item 
struct \hyperlink{struct_assimp_1_1_bone_with_hash}{Bone\+With\+Hash}
\begin{DoxyCompactList}\small\item\em Helper data structure for \hyperlink{class_assimp_1_1_scene_combiner_a4edb3acefc33160d667f47c045ef6ba8}{Scene\+Combiner\+::\+Merge\+Bones}. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_b_v_h_loader}{B\+V\+H\+Loader}
\item 
class \hyperlink{class_assimp_1_1_byte_swap}{Byte\+Swap}
\item 
class \hyperlink{class_assimp_1_1_calc_tangents_process}{Calc\+Tangents\+Process}
\item 
class \hyperlink{class_assimp_1_1_c_i_o_stream_wrapper}{C\+I\+O\+Stream\+Wrapper}
\item 
class \hyperlink{class_assimp_1_1_c_i_o_system_wrapper}{C\+I\+O\+System\+Wrapper}
\item 
class \hyperlink{class_assimp_1_1_c_irr_x_m_l___i_o_stream_reader}{C\+Irr\+X\+M\+L\+\_\+\+I\+O\+Stream\+Reader}
\begin{DoxyCompactList}\small\item\em Utility class to make Irr\+X\+M\+L work together with our custom I\+O system See the Irr\+X\+M\+L docs for more details. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_c_o_b_importer}{C\+O\+B\+Importer}
\item 
class \hyperlink{class_assimp_1_1_collada_exporter}{Collada\+Exporter}
\item 
class \hyperlink{class_assimp_1_1_collada_loader}{Collada\+Loader}
\item 
struct \hyperlink{struct_assimp_1_1_collada_mesh_index}{Collada\+Mesh\+Index}
\item 
class \hyperlink{class_assimp_1_1_collada_parser}{Collada\+Parser}
\item 
class \hyperlink{class_assimp_1_1_compute_spatial_sort_process}{Compute\+Spatial\+Sort\+Process}
\item 
class \hyperlink{class_assimp_1_1_compute_u_v_mapping_process}{Compute\+U\+V\+Mapping\+Process}
\item 
class \hyperlink{class_assimp_1_1_c_s_m_importer}{C\+S\+M\+Importer}
\item 
class \hyperlink{class_assimp_1_1_debone_process}{Debone\+Process}
\item 
class \hyperlink{class_assimp_1_1_default_i_o_stream}{Default\+I\+O\+Stream}
\begin{DoxyCompactList}\small\item\em Default I\+O implementation, use standard I\+O operations. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_default_i_o_system}{Default\+I\+O\+System}
\item 
class \hyperlink{class_assimp_1_1_default_logger}{Default\+Logger}
\begin{DoxyCompactList}\small\item\em C\+P\+P-\/\+A\+P\+I\+: Primary logging facility of \hyperlink{class_assimp}{Assimp}. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_default_progress_handler}{Default\+Progress\+Handler}
\begin{DoxyCompactList}\small\item\em \hyperlink{struct_internal}{Internal} default implementation of the \hyperlink{class_progress_handler}{Progress\+Handler} interface. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_destroy_spatial_sort_process}{Destroy\+Spatial\+Sort\+Process}
\item 
class \hyperlink{class_assimp_1_1_discreet3_d_s_importer}{Discreet3\+D\+S\+Importer}
\item 
class \hyperlink{class_assimp_1_1_d_x_f_importer}{D\+X\+F\+Importer}
\item 
class \hyperlink{class_assimp_1_1_exporter}{Exporter}
\item 
class \hyperlink{class_assimp_1_1_exporter_pimpl}{Exporter\+Pimpl}
\item 
class \hyperlink{class_assimp_1_1_f_b_x_importer}{F\+B\+X\+Importer}
\item 
class \hyperlink{class_assimp_1_1_file_log_stream}{File\+Log\+Stream}
\begin{DoxyCompactList}\small\item\em Logstream to write into a file. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_file_system_filter}{File\+System\+Filter}
\item 
class \hyperlink{class_assimp_1_1_find_degenerates_process}{Find\+Degenerates\+Process}
\item 
class \hyperlink{class_assimp_1_1_find_instances_process}{Find\+Instances\+Process}
\begin{DoxyCompactList}\small\item\em A post-\/processing steps to search for instanced meshes. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_find_invalid_data_process}{Find\+Invalid\+Data\+Process}
\item 
class \hyperlink{class_assimp_1_1_fix_infacing_normals_process}{Fix\+Infacing\+Normals\+Process}
\item 
class \hyperlink{class_assimp_1_1_flip_u_vs_process}{Flip\+U\+Vs\+Process}
\item 
class \hyperlink{class_assimp_1_1_flip_winding_order_process}{Flip\+Winding\+Order\+Process}
\item 
class \hyperlink{class_assimp_1_1_gen_face_normals_process}{Gen\+Face\+Normals\+Process}
\item 
class \hyperlink{class_assimp_1_1_gen_vertex_normals_process}{Gen\+Vertex\+Normals\+Process}
\item 
class \hyperlink{class_assimp_1_1_h_m_p_importer}{H\+M\+P\+Importer}
\item 
class \hyperlink{class_assimp_1_1_i_f_c_importer}{I\+F\+C\+Importer}
\item 
class \hyperlink{class_assimp_1_1_importer}{Importer}
\item 
class \hyperlink{class_assimp_1_1_improve_cache_locality_process}{Improve\+Cache\+Locality\+Process}
\item 
class \hyperlink{class_assimp_1_1_i_o_stream}{I\+O\+Stream}
\begin{DoxyCompactList}\small\item\em C\+P\+P-\/\+A\+P\+I\+: Class to handle file I/\+O for C++. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_i_o_system}{I\+O\+System}
\begin{DoxyCompactList}\small\item\em C\+P\+P-\/\+A\+P\+I\+: Interface to the file system. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_i_r_r_importer}{I\+R\+R\+Importer}
\item 
class \hyperlink{class_assimp_1_1_irrlicht_base}{Irrlicht\+Base}
\item 
class \hyperlink{class_assimp_1_1_i_r_r_mesh_importer}{I\+R\+R\+Mesh\+Importer}
\item 
class \hyperlink{class_assimp_1_1_join_vertices_process}{Join\+Vertices\+Process}
\item 
class \hyperlink{class_assimp_1_1_key_iterator}{Key\+Iterator}
\item 
class \hyperlink{class_assimp_1_1_limit_bone_weights_process}{Limit\+Bone\+Weights\+Process}
\item 
class \hyperlink{class_assimp_1_1_line_splitter}{Line\+Splitter}
\item 
struct \hyperlink{struct_assimp_1_1_load_request}{Load\+Request}
\item 
class \hyperlink{class_assimp_1_1_log_functions}{Log\+Functions}
\item 
class \hyperlink{class_assimp_1_1_logger}{Logger}
\begin{DoxyCompactList}\small\item\em C\+P\+P-\/\+A\+P\+I\+: Abstract interface for logger implementations. \hyperlink{class_assimp}{Assimp} provides a default implementation and uses it for almost all logging stuff ('\hyperlink{class_assimp_1_1_default_logger}{Default\+Logger}'). This class defines just basic logging behaviour and is not of interest for you. Instead, take a look at \#\+Default\+Logger. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_log_stream}{Log\+Stream}
\begin{DoxyCompactList}\small\item\em C\+P\+P-\/\+A\+P\+I\+: Abstract interface for log stream implementations. \end{DoxyCompactList}\item 
struct \hyperlink{struct_assimp_1_1_log_stream_info}{Log\+Stream\+Info}
\item 
class \hyperlink{class_assimp_1_1_l_w_o_importer}{L\+W\+O\+Importer}
\item 
class \hyperlink{class_assimp_1_1_l_w_s_importer}{L\+W\+S\+Importer}
\item 
class \hyperlink{class_assimp_1_1_make_left_handed_process}{Make\+Left\+Handed\+Process}
\begin{DoxyCompactList}\small\item\em The \hyperlink{class_assimp_1_1_make_left_handed_process}{Make\+Left\+Handed\+Process} converts all imported data to a left-\/handed coordinate system. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_make_verbose_format_process}{Make\+Verbose\+Format\+Process}
\item 
class \hyperlink{class_assimp_1_1_m_d2_importer}{M\+D2\+Importer}
\item 
class \hyperlink{class_assimp_1_1_m_d3_importer}{M\+D3\+Importer}
\begin{DoxyCompactList}\small\item\em \hyperlink{class_assimp_1_1_importer}{Importer} class to load M\+D3 files. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_m_d5_importer}{M\+D5\+Importer}
\item 
class \hyperlink{class_assimp_1_1_m_d_c_importer}{M\+D\+C\+Importer}
\item 
class \hyperlink{class_assimp_1_1_m_d_l_importer}{M\+D\+L\+Importer}
\begin{DoxyCompactList}\small\item\em Class to load M\+D\+L files. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_memory_i_o_stream}{Memory\+I\+O\+Stream}
\item 
class \hyperlink{class_assimp_1_1_memory_i_o_system}{Memory\+I\+O\+System}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser}{Min\+Max\+Chooser}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01ai_color4t_3_01_t_01_4_01_4}{Min\+Max\+Chooser$<$ ai\+Color4t$<$ T $>$ $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01ai_quaterniont_3_01_t_01_4_01_4}{Min\+Max\+Chooser$<$ ai\+Quaterniont$<$ T $>$ $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01ai_quat_key_01_4}{Min\+Max\+Chooser$<$ ai\+Quat\+Key $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01ai_vector2t_3_01_t_01_4_01_4}{Min\+Max\+Chooser$<$ ai\+Vector2t$<$ T $>$ $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01ai_vector3t_3_01_t_01_4_01_4}{Min\+Max\+Chooser$<$ ai\+Vector3t$<$ T $>$ $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01ai_vector_key_01_4}{Min\+Max\+Chooser$<$ ai\+Vector\+Key $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01ai_vertex_weight_01_4}{Min\+Max\+Chooser$<$ ai\+Vertex\+Weight $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01double_01_4}{Min\+Max\+Chooser$<$ double $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01float_01_4}{Min\+Max\+Chooser$<$ float $>$}
\item 
struct \hyperlink{struct_assimp_1_1_min_max_chooser_3_01unsigned_01int_01_4}{Min\+Max\+Chooser$<$ unsigned int $>$}
\item 
struct \hyperlink{struct_assimp_1_1mpred}{mpred}
\item 
class \hyperlink{class_assimp_1_1_m_s3_d_importer}{M\+S3\+D\+Importer}
\item 
class \hyperlink{class_assimp_1_1_n_d_o_importer}{N\+D\+O\+Importer}
\begin{DoxyCompactList}\small\item\em \hyperlink{class_assimp_1_1_importer}{Importer} class to load meshes from Nendo. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_n_f_f_importer}{N\+F\+F\+Importer}
\item 
struct \hyperlink{struct_assimp_1_1_node_attachment_info}{Node\+Attachment\+Info}
\item 
class \hyperlink{class_assimp_1_1_null_logger}{Null\+Logger}
\begin{DoxyCompactList}\small\item\em C\+P\+P-\/\+A\+P\+I\+: Empty logging implementation. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_obj_exporter}{Obj\+Exporter}
\item 
class \hyperlink{class_assimp_1_1_obj_file_importer}{Obj\+File\+Importer}
\begin{DoxyCompactList}\small\item\em Imports a waveform obj file. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_obj_file_mtl_importer}{Obj\+File\+Mtl\+Importer}
\begin{DoxyCompactList}\small\item\em Loads the material description from a mtl file. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_obj_file_parser}{Obj\+File\+Parser}
\begin{DoxyCompactList}\small\item\em Parser for a obj waveform file. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_o_f_f_importer}{O\+F\+F\+Importer}
\item 
class \hyperlink{class_assimp_1_1_optimize_graph_process}{Optimize\+Graph\+Process}
\begin{DoxyCompactList}\small\item\em Postprocessing step to optimize the scenegraph. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_optimize_meshes_process}{Optimize\+Meshes\+Process}
\begin{DoxyCompactList}\small\item\em Postprocessing step to optimize mesh usage. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_ply_exporter}{Ply\+Exporter}
\item 
class \hyperlink{class_assimp_1_1_p_l_y_importer}{P\+L\+Y\+Importer}
\item 
class \hyperlink{class_assimp_1_1_pretransform_vertices}{Pretransform\+Vertices}
\item 
class \hyperlink{class_assimp_1_1_progress_handler}{Progress\+Handler}
\begin{DoxyCompactList}\small\item\em C\+P\+P-\/\+A\+P\+I\+: Abstract interface for custom progress report receivers. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_q3_b_s_p_file_importer}{Q3\+B\+S\+P\+File\+Importer}
\item 
class \hyperlink{class_assimp_1_1_q3_b_s_p_file_parser}{Q3\+B\+S\+P\+File\+Parser}
\item 
class \hyperlink{class_assimp_1_1_q3_d_importer}{Q3\+D\+Importer}
\item 
class \hyperlink{class_assimp_1_1_r_a_w_importer}{R\+A\+W\+Importer}
\item 
class \hyperlink{class_assimp_1_1_remove_redundant_mats_process}{Remove\+Redundant\+Mats\+Process}
\item 
class \hyperlink{class_assimp_1_1_remove_v_c_process}{Remove\+V\+C\+Process}
\item 
class \hyperlink{class_assimp_1_1_scene_combiner}{Scene\+Combiner}
\begin{DoxyCompactList}\small\item\em Static helper class providing various utilities to merge two scenes. It is intended as internal utility and N\+O\+T for use by applications. \end{DoxyCompactList}\item 
struct \hyperlink{struct_assimp_1_1_scene_helper}{Scene\+Helper}
\begin{DoxyCompactList}\small\item\em Utility for \hyperlink{class_assimp_1_1_scene_combiner}{Scene\+Combiner}. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_scene_preprocessor}{Scene\+Preprocessor}
\item 
struct \hyperlink{struct_assimp_1_1_scene_private_data}{Scene\+Private\+Data}
\item 
struct \hyperlink{struct_assimp_1_1_scope_guard}{Scope\+Guard}
\item 
class \hyperlink{class_assimp_1_1_s_g_spatial_sort}{S\+G\+Spatial\+Sort}
\item 
class \hyperlink{class_assimp_1_1_shared_post_process_info}{Shared\+Post\+Process\+Info}
\item 
class \hyperlink{class_assimp_1_1_skeleton_mesh_builder}{Skeleton\+Mesh\+Builder}
\item 
class \hyperlink{class_assimp_1_1_s_m_d_importer}{S\+M\+D\+Importer}
\begin{DoxyCompactList}\small\item\em namespace S\+M\+D \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_sort_by_p_type_process}{Sort\+By\+P\+Type\+Process}
\item 
class \hyperlink{class_assimp_1_1_spatial_sort}{Spatial\+Sort}
\item 
class \hyperlink{class_assimp_1_1_split_by_bone_count_process}{Split\+By\+Bone\+Count\+Process}
\item 
class \hyperlink{class_assimp_1_1_split_large_meshes_process___triangle}{Split\+Large\+Meshes\+Process\+\_\+\+Triangle}
\item 
class \hyperlink{class_assimp_1_1_split_large_meshes_process___vertex}{Split\+Large\+Meshes\+Process\+\_\+\+Vertex}
\item 
class \hyperlink{class_assimp_1_1_standard_shapes}{Standard\+Shapes}
\begin{DoxyCompactList}\small\item\em Helper class to generate vertex buffers for standard geometric shapes, such as cylinders, cones, boxes, spheres, elipsoids ... . \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_std_o_stream_log_stream}{Std\+O\+Stream\+Log\+Stream}
\begin{DoxyCompactList}\small\item\em Logs into a std\+::ostream. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_s_t_l_exporter}{S\+T\+L\+Exporter}
\item 
class \hyperlink{class_assimp_1_1_s_t_l_importer}{S\+T\+L\+Importer}
\item 
struct \hyperlink{struct_assimp_1_1_s_transform_vec_info}{S\+Transform\+Vec\+Info}
\item 
class \hyperlink{singleton_assimp_1_1_stream_reader}{Stream\+Reader}
\item 
class \hyperlink{class_assimp_1_1_subdivider}{Subdivider}
\item 
class \hyperlink{class_assimp_1_1_target_animation_helper}{Target\+Animation\+Helper}
\item 
class \hyperlink{class_assimp_1_1_terragen_importer}{Terragen\+Importer}
\begin{DoxyCompactList}\small\item\em \hyperlink{class_assimp_1_1_importer}{Importer} class to load Terragen (0.\+9) terrain files. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_texture_transform_step}{Texture\+Transform\+Step}
\item 
class \hyperlink{class_assimp_1_1_triangulate_process}{Triangulate\+Process}
\item 
struct \hyperlink{struct_assimp_1_1_t_t_update_info}{T\+T\+Update\+Info}
\item 
class \hyperlink{class_assimp_1_1_unreal_importer}{Unreal\+Importer}
\begin{DoxyCompactList}\small\item\em \hyperlink{class_assimp_1_1_importer}{Importer} class to load U\+N\+R\+E\+A\+L files ($\ast$.3d) \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_validate_d_s_process}{Validate\+D\+S\+Process}
\item 
class \hyperlink{class_assimp_1_1_vertex}{Vertex}
\item 
class \hyperlink{class_assimp_1_1_vertex_triangle_adjacency}{Vertex\+Triangle\+Adjacency}
\begin{DoxyCompactList}\small\item\em The \hyperlink{class_assimp_1_1_vertex_triangle_adjacency}{Vertex\+Triangle\+Adjacency} class computes a vertex-\/triangle adjacency map from a given index buffer. \end{DoxyCompactList}\item 
class \hyperlink{class_assimp_1_1_x_file_importer}{X\+File\+Importer}
\item 
class \hyperlink{class_assimp_1_1_x_file_parser}{X\+File\+Parser}
\item 
class \hyperlink{class_assimp_1_1_x_g_l_importer}{X\+G\+L\+Importer}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{namespace_assimp_a1242048c6931721405704fa72a056321}{{\footnotesize template$<$typename T $>$ }\\std\+::size\+\_\+t {\bfseries Copy} (uint8\+\_\+t $\ast$data, T \&field)}\label{namespace_assimp_a1242048c6931721405704fa72a056321}

\item 
\hypertarget{namespace_assimp_ad31d6c4f86478e5424d71b5693993583}{void {\bfseries Export\+Scene\+Collada} (const char $\ast$p\+File, \hyperlink{class_assimp_1_1_i_o_system}{I\+O\+System} $\ast$p\+I\+O\+System, const \hyperlink{structai_scene}{ai\+Scene} $\ast$p\+Scene)}\label{namespace_assimp_ad31d6c4f86478e5424d71b5693993583}

\item 
\hypertarget{namespace_assimp_ac346b524b4868a3700e756247dbaba15}{void {\bfseries Get\+Post\+Processing\+Step\+Instance\+List} (std\+::vector$<$ \hyperlink{class_assimp_1_1_base_process}{Base\+Process} $\ast$ $>$ \&out)}\label{namespace_assimp_ac346b524b4868a3700e756247dbaba15}

\item 
\hypertarget{namespace_assimp_a3ef2319b30736c8a8889b3b33434cb48}{void {\bfseries Export\+Scene\+Obj} (const char $\ast$, \hyperlink{class_assimp_1_1_i_o_system}{I\+O\+System} $\ast$, const \hyperlink{structai_scene}{ai\+Scene} $\ast$)}\label{namespace_assimp_a3ef2319b30736c8a8889b3b33434cb48}

\item 
\hypertarget{namespace_assimp_a5ef876901d5e55e2e97eb280f9e44602}{void {\bfseries Export\+Scene\+S\+T\+L} (const char $\ast$, \hyperlink{class_assimp_1_1_i_o_system}{I\+O\+System} $\ast$, const \hyperlink{structai_scene}{ai\+Scene} $\ast$)}\label{namespace_assimp_a5ef876901d5e55e2e97eb280f9e44602}

\item 
\hypertarget{namespace_assimp_ad67ca688ca641a50437c43d14eb010d3}{void {\bfseries Export\+Scene\+S\+T\+L\+Binary} (const char $\ast$, \hyperlink{class_assimp_1_1_i_o_system}{I\+O\+System} $\ast$, const \hyperlink{structai_scene}{ai\+Scene} $\ast$)}\label{namespace_assimp_ad67ca688ca641a50437c43d14eb010d3}

\item 
\hypertarget{namespace_assimp_a8692c74d797b3368f1cb9f7f65871673}{void {\bfseries Export\+Scene\+Ply} (const char $\ast$, \hyperlink{class_assimp_1_1_i_o_system}{I\+O\+System} $\ast$, const \hyperlink{structai_scene}{ai\+Scene} $\ast$)}\label{namespace_assimp_a8692c74d797b3368f1cb9f7f65871673}

\item 
\hypertarget{namespace_assimp_a4d11453b42e35cc6767f25d12008042b}{void {\bfseries Export\+Scene3\+D\+S} (const char $\ast$, \hyperlink{class_assimp_1_1_i_o_system}{I\+O\+System} $\ast$, const \hyperlink{structai_scene}{ai\+Scene} $\ast$)}\label{namespace_assimp_a4d11453b42e35cc6767f25d12008042b}

\item 
\hypertarget{namespace_assimp_a0b34bad3b9ad1b488391ede9b4f23c07}{unsigned int {\bfseries strtoul10} (const char $\ast$in, const char $\ast$$\ast$out=0)}\label{namespace_assimp_a0b34bad3b9ad1b488391ede9b4f23c07}

\item 
\hypertarget{namespace_assimp_a1c1db8ffa6363c57660b3d1d0dc8ed3f}{unsigned int {\bfseries strtoul8} (const char $\ast$in, const char $\ast$$\ast$out=0)}\label{namespace_assimp_a1c1db8ffa6363c57660b3d1d0dc8ed3f}

\item 
\hypertarget{namespace_assimp_a358486ae5448785a4eeb0b6d9ebe929b}{unsigned int {\bfseries strtoul16} (const char $\ast$in, const char $\ast$$\ast$out=0)}\label{namespace_assimp_a358486ae5448785a4eeb0b6d9ebe929b}

\item 
\hypertarget{namespace_assimp_a6bb609222363ab9ba88298597056d65f}{unsigned int {\bfseries Hex\+Digit\+To\+Decimal} (char in)}\label{namespace_assimp_a6bb609222363ab9ba88298597056d65f}

\item 
\hypertarget{namespace_assimp_a50f9e78be9d92b2140273c577d24ff47}{uint8\+\_\+t {\bfseries Hex\+Octet\+To\+Decimal} (const char $\ast$in)}\label{namespace_assimp_a50f9e78be9d92b2140273c577d24ff47}

\item 
\hypertarget{namespace_assimp_a6712580fbbfe4f27e13815abf8e2a0e0}{int {\bfseries strtol10} (const char $\ast$in, const char $\ast$$\ast$out=0)}\label{namespace_assimp_a6712580fbbfe4f27e13815abf8e2a0e0}

\item 
\hypertarget{namespace_assimp_a90b8b671fcfb5f9c2c1be40056cdef27}{unsigned int {\bfseries strtoul\+\_\+cppstyle} (const char $\ast$in, const char $\ast$$\ast$out=0)}\label{namespace_assimp_a90b8b671fcfb5f9c2c1be40056cdef27}

\item 
\hypertarget{namespace_assimp_a591ca644fe029794191b24cb7b7419c5}{uint64\+\_\+t {\bfseries strtoul10\+\_\+64} (const char $\ast$in, const char $\ast$$\ast$out=0, unsigned int $\ast$max\+\_\+inout=0)}\label{namespace_assimp_a591ca644fe029794191b24cb7b7419c5}

\item 
{\footnotesize template$<$typename Real $>$ }\\const char $\ast$ \hyperlink{namespace_assimp_a99179da009833bb3b0b72b469edf6370}{fast\+\_\+atoreal\+\_\+move} (const char $\ast$c, Real \&out, bool check\+\_\+comma=true)
\item 
\hypertarget{namespace_assimp_acbb007b2ed4352f7d41c462828c455e4}{float {\bfseries fast\+\_\+atof} (const char $\ast$c)}\label{namespace_assimp_acbb007b2ed4352f7d41c462828c455e4}

\item 
\hypertarget{namespace_assimp_a4b67db79e3284e835b5be9bc0c1e4a2a}{float {\bfseries fast\+\_\+atof} (const char $\ast$c, const char $\ast$$\ast$cout)}\label{namespace_assimp_a4b67db79e3284e835b5be9bc0c1e4a2a}

\item 
\hypertarget{namespace_assimp_aa9efe47f47767fd6f9f4cb9162279638}{float {\bfseries fast\+\_\+atof} (const char $\ast$$\ast$inout)}\label{namespace_assimp_aa9efe47f47767fd6f9f4cb9162279638}

\item 
\hypertarget{namespace_assimp_a1959fe3a6e774623cd8044c67936ce9d}{double {\bfseries fast\+\_\+atod} (const char $\ast$c)}\label{namespace_assimp_a1959fe3a6e774623cd8044c67936ce9d}

\item 
\hypertarget{namespace_assimp_a02020d6e063cd781c592b92da2d6a6f4}{double {\bfseries fast\+\_\+atod} (const char $\ast$c, const char $\ast$$\ast$cout)}\label{namespace_assimp_a02020d6e063cd781c592b92da2d6a6f4}

\item 
\hypertarget{namespace_assimp_ad6f53b0143eb1df51a745c04e9e5dec7}{double {\bfseries fast\+\_\+atod} (const char $\ast$$\ast$inout)}\label{namespace_assimp_ad6f53b0143eb1df51a745c04e9e5dec7}

\item 
\hypertarget{namespace_assimp_a4ecbaed1f4bde28a7774b4b8dc31723d}{bool {\bfseries Is\+Hex} (char s)}\label{namespace_assimp_a4ecbaed1f4bde28a7774b4b8dc31723d}

\item 
uint64\+\_\+t \hyperlink{namespace_assimp_aa55ce1d958f3732c90f748b2e7d44293}{Get\+Mesh\+Hash} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$in)
\begin{DoxyCompactList}\small\item\em Get a pseudo(!)-\/hash representing a mesh. \end{DoxyCompactList}\item 
bool \hyperlink{namespace_assimp_a199e9276257039959c3a5d2110b36980}{Compare\+Arrays} (const \hyperlink{structai_vector3_d}{ai\+Vector3\+D} $\ast$first, const \hyperlink{structai_vector3_d}{ai\+Vector3\+D} $\ast$second, unsigned int size, float e)
\begin{DoxyCompactList}\small\item\em Perform a component-\/wise comparison of two arrays. \end{DoxyCompactList}\item 
\hypertarget{namespace_assimp_a9a59e9539ff88bcc39288fc026c720c4}{bool {\bfseries Compare\+Arrays} (const \hyperlink{structai_color4_d}{ai\+Color4\+D} $\ast$first, const \hyperlink{structai_color4_d}{ai\+Color4\+D} $\ast$second, unsigned int size, float e)}\label{namespace_assimp_a9a59e9539ff88bcc39288fc026c720c4}

\item 
\hypertarget{namespace_assimp_aff98691265aed9a04bc7d08806b9497b}{void {\bfseries Get\+Importer\+Instance\+List} (std\+::vector$<$ \hyperlink{class_assimp_1_1_base_importer}{Base\+Importer} $\ast$ $>$ \&out)}\label{namespace_assimp_aff98691265aed9a04bc7d08806b9497b}

\item 
\hypertarget{namespace_assimp_a3ee32879e32a479a0488614f64408fd9}{void {\bfseries Color\+From\+A\+R\+G\+B\+Packed} (uint32\+\_\+t in, \hyperlink{structai_color4_d}{ai\+Color4\+D} \&clr)}\label{namespace_assimp_a3ee32879e32a479a0488614f64408fd9}

\item 
uint32\+\_\+t \hyperlink{namespace_assimp_aeec12ff2ff74693da249187a7c9f1fdd}{Compute\+Material\+Hash} (const \hyperlink{classai_material}{ai\+Material} $\ast$mat, bool include\+Mat\+Name=false)
\item 
{\footnotesize template$<$class char\+\_\+t $>$ }\\bool \hyperlink{namespace_assimp_a98cbb5f7f096bb5e6b42e08d4f65456a}{is\+End\+Of\+Buffer} (char\+\_\+t it, char\+\_\+t end)
\begin{DoxyCompactList}\small\item\em Returns true, if the last entry of the buffer is reached. \end{DoxyCompactList}\item 
bool \hyperlink{namespace_assimp_ac0fa4924a9d69a0c625c44af70de4793}{is\+Separator} (char token)
\begin{DoxyCompactList}\small\item\em Returns true, if token is a space on any supported platform. \end{DoxyCompactList}\item 
bool \hyperlink{namespace_assimp_a85a3905e1425845270407c4b081fa02f}{is\+New\+Line} (char token)
\begin{DoxyCompactList}\small\item\em Returns true, fi token id a new line marking token. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Char\+\_\+\+T $>$ }\\Char\+\_\+\+T \hyperlink{namespace_assimp_a136ee23a615c5889f37d4e22ec7a343a}{get\+Next\+Word} (Char\+\_\+\+T p\+Buffer, Char\+\_\+\+T p\+End)
\begin{DoxyCompactList}\small\item\em Returns next word separated by a space. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Char\+\_\+\+T $>$ }\\Char\+\_\+\+T \hyperlink{namespace_assimp_ada8c8de6132e8d219622b325f3109607}{get\+Next\+Token} (Char\+\_\+\+T p\+Buffer, Char\+\_\+\+T p\+End)
\begin{DoxyCompactList}\small\item\em Returns pointer a next token. \end{DoxyCompactList}\item 
{\footnotesize template$<$class char\+\_\+t $>$ }\\char\+\_\+t \hyperlink{namespace_assimp_a70862408fff68ee98076ad089ee1ae7b}{skip\+Line} (char\+\_\+t it, char\+\_\+t end, unsigned int \&ui\+Line)
\begin{DoxyCompactList}\small\item\em Skips a line. \end{DoxyCompactList}\item 
{\footnotesize template$<$class char\+\_\+t $>$ }\\char\+\_\+t \hyperlink{namespace_assimp_a0f8daeb06b4e861a2152c33413e6eae1}{get\+Name} (char\+\_\+t it, char\+\_\+t end, std\+::string \&name)
\begin{DoxyCompactList}\small\item\em Get a name from the current line. Preserve space in the middle, but trim it at the end. \end{DoxyCompactList}\item 
{\footnotesize template$<$class char\+\_\+t $>$ }\\char\+\_\+t \hyperlink{namespace_assimp_a9fa5e810cd3a03f8f0b9b232a9c2adb9}{Copy\+Next\+Word} (char\+\_\+t it, char\+\_\+t end, char $\ast$p\+Buffer, size\+\_\+t length)
\begin{DoxyCompactList}\small\item\em Get next word from given line. \end{DoxyCompactList}\item 
{\footnotesize template$<$class char\+\_\+t $>$ }\\char\+\_\+t \hyperlink{namespace_assimp_a3a64f936048746e10d0aa50e3eee9099}{get\+Float} (char\+\_\+t it, char\+\_\+t end, float \&value)
\begin{DoxyCompactList}\small\item\em Get next float from given line. \end{DoxyCompactList}\item 
{\footnotesize template$<$class string\+\_\+type $>$ }\\unsigned int \hyperlink{namespace_assimp_add92ce34a50273a4d925ec78a7fc658a}{tokenize} (const string\+\_\+type \&str, std\+::vector$<$ string\+\_\+type $>$ \&tokens, const string\+\_\+type \&delimiters)
\begin{DoxyCompactList}\small\item\em Will perform a simple tokenize. \end{DoxyCompactList}\item 
\hypertarget{namespace_assimp_a1885e8fcc335cbb5e9e2498ddbda7ea9}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E char\+\_\+t {\bfseries To\+Lower} (char\+\_\+t in)}\label{namespace_assimp_a1885e8fcc335cbb5e9e2498ddbda7ea9}

\item 
\hypertarget{namespace_assimp_ae962b1f79ef7c286cfa1ba76b557f1b3}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E char\+\_\+t {\bfseries To\+Upper} (char\+\_\+t in)}\label{namespace_assimp_ae962b1f79ef7c286cfa1ba76b557f1b3}

\item 
\hypertarget{namespace_assimp_a704d02684243c28d97f16184ca7da160}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Is\+Upper} (char\+\_\+t in)}\label{namespace_assimp_a704d02684243c28d97f16184ca7da160}

\item 
\hypertarget{namespace_assimp_a9b1362fc8d49819d06aae521117255aa}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Is\+Lower} (char\+\_\+t in)}\label{namespace_assimp_a9b1362fc8d49819d06aae521117255aa}

\item 
\hypertarget{namespace_assimp_a2dc3cfed4430c305908c17c403ced49c}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Is\+Space} (char\+\_\+t in)}\label{namespace_assimp_a2dc3cfed4430c305908c17c403ced49c}

\item 
\hypertarget{namespace_assimp_a99092e9b63e3e8bb88dc63e141d7157f}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Is\+Line\+End} (char\+\_\+t in)}\label{namespace_assimp_a99092e9b63e3e8bb88dc63e141d7157f}

\item 
\hypertarget{namespace_assimp_a3883df5611e6ba0bd986fd5694c47e35}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Is\+Space\+Or\+New\+Line} (char\+\_\+t in)}\label{namespace_assimp_a3883df5611e6ba0bd986fd5694c47e35}

\item 
\hypertarget{namespace_assimp_a0c02640871537ab3d13415909863c27f}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Skip\+Spaces} (const char\+\_\+t $\ast$in, const char\+\_\+t $\ast$$\ast$out)}\label{namespace_assimp_a0c02640871537ab3d13415909863c27f}

\item 
\hypertarget{namespace_assimp_a05f1054ce31db2fb1ef96529e9f186fd}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Skip\+Spaces} (const char\+\_\+t $\ast$$\ast$inout)}\label{namespace_assimp_a05f1054ce31db2fb1ef96529e9f186fd}

\item 
\hypertarget{namespace_assimp_a6fd6d20616f404b05a6f90bae0ed227e}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Skip\+Line} (const char\+\_\+t $\ast$in, const char\+\_\+t $\ast$$\ast$out)}\label{namespace_assimp_a6fd6d20616f404b05a6f90bae0ed227e}

\item 
\hypertarget{namespace_assimp_ae7c92b4db3cd8a2966c709b01669835f}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Skip\+Line} (const char\+\_\+t $\ast$$\ast$inout)}\label{namespace_assimp_ae7c92b4db3cd8a2966c709b01669835f}

\item 
\hypertarget{namespace_assimp_a42855b2f408a9a00f870fc1bea2452d8}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Skip\+Spaces\+And\+Line\+End} (const char\+\_\+t $\ast$in, const char\+\_\+t $\ast$$\ast$out)}\label{namespace_assimp_a42855b2f408a9a00f870fc1bea2452d8}

\item 
\hypertarget{namespace_assimp_a36236d2b842108e2403870e394be2f6d}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Skip\+Spaces\+And\+Line\+End} (const char\+\_\+t $\ast$$\ast$inout)}\label{namespace_assimp_a36236d2b842108e2403870e394be2f6d}

\item 
\hypertarget{namespace_assimp_acbab05efb1e793c0ff7bd62c7ebbdafd}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Get\+Next\+Line} (const char\+\_\+t $\ast$\&\hyperlink{structbuffer}{buffer}, char\+\_\+t out\mbox{[}4096\mbox{]})}\label{namespace_assimp_acbab05efb1e793c0ff7bd62c7ebbdafd}

\item 
\hypertarget{namespace_assimp_a66776110eb3e45aecf16baebd71ca713}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Is\+Numeric} (char\+\_\+t in)}\label{namespace_assimp_a66776110eb3e45aecf16baebd71ca713}

\item 
\hypertarget{namespace_assimp_ae4567ff539c9f9fc2b63598edbd3d4be}{{\footnotesize template$<$class char\+\_\+t $>$ }\\A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool {\bfseries Token\+Match} (char\+\_\+t $\ast$\&in, const char $\ast$token, unsigned int len)}\label{namespace_assimp_ae4567ff539c9f9fc2b63598edbd3d4be}

\item 
A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool \hyperlink{namespace_assimp_a3bd333f65bd8da9590190ed27987e47f}{Token\+Match\+I} (const char $\ast$\&in, const char $\ast$token, unsigned int len)
\begin{DoxyCompactList}\small\item\em Case-\/ignoring version of Token\+Match. \end{DoxyCompactList}\item 
\hypertarget{namespace_assimp_afcdf7e2568e40907cea2f7025b0a76a3}{A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E void {\bfseries Skip\+Token} (const char $\ast$\&in)}\label{namespace_assimp_afcdf7e2568e40907cea2f7025b0a76a3}

\item 
\hypertarget{namespace_assimp_a6dc54015f5b7ec09336559345d8bec9b}{A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E std\+::string {\bfseries Get\+Next\+Token} (const char $\ast$\&in)}\label{namespace_assimp_a6dc54015f5b7ec09336559345d8bec9b}

\item 
{\footnotesize template$<$typename T $>$ }\\double \hyperlink{namespace_assimp_af60598b5a7161a8c918b65fea426c08d}{Get\+Area2\+D} (const T \&v1, const T \&v2, const T \&v3)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \hyperlink{namespace_assimp_a8befcf1030197c725d93b98d558bec85}{On\+Left\+Side\+Of\+Line2\+D} (const T \&p0, const T \&p1, const T \&p2)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \hyperlink{namespace_assimp_adfc6439fa2efcc68e6e1591411dc3ab8}{Point\+In\+Triangle2\+D} (const T \&p0, const T \&p1, const T \&p2, const T \&pp)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \hyperlink{namespace_assimp_a8d01c8219b0bc01a2ecf0012ed671889}{Is\+C\+C\+W} (T $\ast$in, size\+\_\+t npoints)
\item 
{\footnotesize template$<$int ofs\+\_\+x, int ofs\+\_\+y, int ofs\+\_\+z, typename T\+Real $>$ }\\void \hyperlink{namespace_assimp_af542a87f4818ee15b1ee8bd25c480d82}{Newell\+Normal} (ai\+Vector3t$<$ T\+Real $>$ \&out, int num, T\+Real $\ast$x, T\+Real $\ast$\hyperlink{_ice_utils_8h_aa7ffaed69623192258fb8679569ff9ba}{y}, T\+Real $\ast$z)
\item 
void \hyperlink{namespace_assimp_a1427aee7ea9b613a4677c68d40d68b3b}{Convert\+List\+To\+Strings} (const std\+::string \&in, std\+::list$<$ std\+::string $>$ \&out)
\begin{DoxyCompactList}\small\item\em Extract single strings from a list of identifiers. \end{DoxyCompactList}\item 
void \hyperlink{namespace_assimp_a40d018d9f497377fa37b58d7c7cb1e56}{Find\+A\+A\+B\+B\+Transformed} (const \hyperlink{structai_mesh}{ai\+Mesh} $\ast$mesh, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&min, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&max, const \hyperlink{structai_matrix4x4}{ai\+Matrix4x4} \&m)
\begin{DoxyCompactList}\small\item\em Compute the \hyperlink{class_a_a_b_b}{A\+A\+B\+B} of a mesh after applying a given transform. \end{DoxyCompactList}\item 
void \hyperlink{namespace_assimp_a4cccef1c4b037b4eda69f9955fe614b4}{Find\+Mesh\+Center} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$mesh, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&out, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&min, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&max)
\begin{DoxyCompactList}\small\item\em Helper function to determine the 'real' center of a mesh. \end{DoxyCompactList}\item 
\hypertarget{namespace_assimp_a11b3e8dea5deb3c5af6f2274b2ef6b64}{void {\bfseries Find\+Mesh\+Center\+Transformed} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$mesh, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&out, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&min, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&max, const \hyperlink{structai_matrix4x4}{ai\+Matrix4x4} \&m)}\label{namespace_assimp_a11b3e8dea5deb3c5af6f2274b2ef6b64}

\item 
\hypertarget{namespace_assimp_a839a9cdc84f95933ad17a2d37893cecc}{void {\bfseries Find\+Mesh\+Center} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$mesh, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&out)}\label{namespace_assimp_a839a9cdc84f95933ad17a2d37893cecc}

\item 
\hypertarget{namespace_assimp_a95a63d56d69ce397fe9df3798d6ef547}{void {\bfseries Find\+Mesh\+Center\+Transformed} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$mesh, \hyperlink{structai_vector3_d}{ai\+Vector3\+D} \&out, const \hyperlink{structai_matrix4x4}{ai\+Matrix4x4} \&m)}\label{namespace_assimp_a95a63d56d69ce397fe9df3798d6ef547}

\item 
\hypertarget{namespace_assimp_affb84e6645fc1086b1c603bac7e66247}{float {\bfseries Compute\+Position\+Epsilon} (const \hyperlink{structai_mesh}{ai\+Mesh} $\ast$p\+Mesh)}\label{namespace_assimp_affb84e6645fc1086b1c603bac7e66247}

\item 
\hypertarget{namespace_assimp_a3b45fa606f06463f34a84ee359b38737}{float {\bfseries Compute\+Position\+Epsilon} (const \hyperlink{structai_mesh}{ai\+Mesh} $\ast$const $\ast$p\+Meshes, size\+\_\+t num)}\label{namespace_assimp_a3b45fa606f06463f34a84ee359b38737}

\item 
\hypertarget{namespace_assimp_a878783b1070e56b553ae32b7ced01865}{unsigned int {\bfseries Get\+Mesh\+V\+Format\+Unique} (const \hyperlink{structai_mesh}{ai\+Mesh} $\ast$pc\+Mesh)}\label{namespace_assimp_a878783b1070e56b553ae32b7ced01865}

\item 
\hypertarget{namespace_assimp_ad9061ea2fffdd9a49a1a56852615270c}{Vertex\+Weight\+Table $\ast$ {\bfseries Compute\+Vertex\+Bone\+Weight\+Table} (const \hyperlink{structai_mesh}{ai\+Mesh} $\ast$p\+Mesh)}\label{namespace_assimp_ad9061ea2fffdd9a49a1a56852615270c}

\item 
\hypertarget{namespace_assimp_a1cd196c316bf715e2d1d35d733823c79}{const char $\ast$ {\bfseries Texture\+Type\+To\+String} (\hyperlink{material_8h_a7dd415ff703a2cc53d1c22ddbbd7dde0}{ai\+Texture\+Type} in)}\label{namespace_assimp_a1cd196c316bf715e2d1d35d733823c79}

\item 
\hypertarget{namespace_assimp_a7fb213704d10e18fc99f6c7130f77a0d}{const char $\ast$ {\bfseries Mapping\+Type\+To\+String} (\hyperlink{material_8h_a6186e909f1ae28133ab10f1b4635b0f9}{ai\+Texture\+Mapping} in)}\label{namespace_assimp_a7fb213704d10e18fc99f6c7130f77a0d}

\item 
\hypertarget{namespace_assimp_a476ab338ceda1bea0692f9dfc1297d77}{\hyperlink{structai_mesh}{ai\+Mesh} $\ast$ {\bfseries Make\+Submesh} (const \hyperlink{structai_mesh}{ai\+Mesh} $\ast$p\+Mesh, const std\+::vector$<$ unsigned int $>$ \&sub\+Mesh\+Faces, unsigned int sub\+Flags)}\label{namespace_assimp_a476ab338ceda1bea0692f9dfc1297d77}

\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespace_assimp_a4bd560c5925177fe3db8c0ef39338b17}{Array\+Bounds} (const T $\ast$in, unsigned int size, T \&min, T \&max)
\begin{DoxyCompactList}\small\item\em Find the min/max values of an array of Ts. \end{DoxyCompactList}\item 
float \hyperlink{namespace_assimp_a19ad49cb7574ea17c7bc1e9376cac0fa}{Get\+Color\+Difference} (const \hyperlink{structai_color4_d}{ai\+Color4\+D} \&p\+Color1, const \hyperlink{structai_color4_d}{ai\+Color4\+D} \&p\+Color2)
\item 
\hypertarget{namespace_assimp_af7e2df7d828c601812df5d814f6018ca}{void {\bfseries Prefix\+String} (\hyperlink{structai_string}{ai\+String} \&string, const char $\ast$prefix, unsigned int len)}\label{namespace_assimp_af7e2df7d828c601812df5d814f6018ca}

\item 
\hypertarget{namespace_assimp_aafb02a2faed5794e0903944358626ce4}{{\footnotesize template$<$typename Type $>$ }\\void {\bfseries Copy\+Ptr\+Array} (\hyperlink{struct_type}{Type} $\ast$$\ast$\&dest, const \hyperlink{struct_type}{Type} $\ast$const $\ast$src, unsigned int num)}\label{namespace_assimp_aafb02a2faed5794e0903944358626ce4}

\item 
\hypertarget{namespace_assimp_ac59eadf404c7070e3fdf3cf42ab7ce8c}{{\footnotesize template$<$typename Type $>$ }\\void {\bfseries Get\+Array\+Copy} (\hyperlink{struct_type}{Type} $\ast$\&dest, unsigned int num)}\label{namespace_assimp_ac59eadf404c7070e3fdf3cf42ab7ce8c}

\item 
\hypertarget{namespace_assimp_a2b232d996d6904712ea1fe230214bc66}{\hyperlink{struct_assimp_1_1_scene_private_data}{Scene\+Private\+Data} $\ast$ {\bfseries Scene\+Priv} (\hyperlink{structai_scene}{ai\+Scene} $\ast$in)}\label{namespace_assimp_a2b232d996d6904712ea1fe230214bc66}

\item 
\hypertarget{namespace_assimp_a125129784406364f0a08260fa93f870b}{const \hyperlink{struct_assimp_1_1_scene_private_data}{Scene\+Private\+Data} $\ast$ {\bfseries Scene\+Priv} (const \hyperlink{structai_scene}{ai\+Scene} $\ast$in)}\label{namespace_assimp_a125129784406364f0a08260fa93f870b}

\item 
\hypertarget{namespace_assimp_ae03f4b36efe4a3c71af475d2079f611a}{void {\bfseries Subdivide} (std\+::vector$<$ \hyperlink{structai_vector3_d}{ai\+Vector3\+D} $>$ \&positions)}\label{namespace_assimp_ae03f4b36efe4a3c71af475d2079f611a}

\item 
unsigned int \hyperlink{namespace_assimp_a95de3dd4de6a42bfed3eb0a9fcea48be}{A\+S\+S\+I\+M\+P\+\_\+itoa10} (char $\ast$out, unsigned int max, int32\+\_\+t number)
\begin{DoxyCompactList}\small\item\em itoa with a fixed base 10 'itoa' is not consistently available on all platforms so it is quite useful to have a small replacement function here. No need to use a full sprintf() if we just want to print a number ... \end{DoxyCompactList}\item 
\hypertarget{namespace_assimp_a780ce39f05ccc110f67a59dd76709112}{{\footnotesize template$<$size\+\_\+t length$>$ }\\unsigned int \hyperlink{namespace_assimp_a780ce39f05ccc110f67a59dd76709112}{A\+S\+S\+I\+M\+P\+\_\+itoa10} (char(\&out)\mbox{[}length\mbox{]}, int32\+\_\+t number)}\label{namespace_assimp_a780ce39f05ccc110f67a59dd76709112}

\begin{DoxyCompactList}\small\item\em itoa with a fixed base 10 (Secure template overload) The compiler should choose this function if he or she is able to determine the size of the array automatically. \end{DoxyCompactList}\item 
int \hyperlink{namespace_assimp_a72851b2740829d0e26ee31da7af20ce6}{A\+S\+S\+I\+M\+P\+\_\+stricmp} (const char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em Helper function to do platform independent string comparison. \end{DoxyCompactList}\item 
int \hyperlink{namespace_assimp_abd7b0704eb33d941b05a778f916cf963}{A\+S\+S\+I\+M\+P\+\_\+stricmp} (const std\+::string \&a, const std\+::string \&b)
\begin{DoxyCompactList}\small\item\em Case independent comparison of two std\+::strings. \end{DoxyCompactList}\item 
int \hyperlink{namespace_assimp_a5718d462fef0070afea1d4ac4e65d4d8}{A\+S\+S\+I\+M\+P\+\_\+strincmp} (const char $\ast$s1, const char $\ast$s2, unsigned int n)
\begin{DoxyCompactList}\small\item\em Helper function to do platform independent string comparison. \end{DoxyCompactList}\item 
unsigned int \hyperlink{namespace_assimp_a7f1165ac9e907c30dbbba7657c651b4e}{integer\+\_\+pow} (unsigned int base, unsigned int power)
\begin{DoxyCompactList}\small\item\em Evaluates an integer power. \end{DoxyCompactList}\item 
\hypertarget{namespace_assimp_a26ab9ab92b7b78ef60b4e63e0dbc2f75}{A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} {\bfseries operator+} (const \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} \&v0, const \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} \&v1)}\label{namespace_assimp_a26ab9ab92b7b78ef60b4e63e0dbc2f75}

\item 
\hypertarget{namespace_assimp_a3b3364133e7a8b1b96d5839dcd53611c}{A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} {\bfseries operator-\/} (const \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} \&v0, const \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} \&v1)}\label{namespace_assimp_a3b3364133e7a8b1b96d5839dcd53611c}

\item 
\hypertarget{namespace_assimp_a1a60235e437afe22941928788d275dd7}{A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} {\bfseries operator$\ast$} (const \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} \&v0, float f)}\label{namespace_assimp_a1a60235e437afe22941928788d275dd7}

\item 
\hypertarget{namespace_assimp_a7d888ec18cace2e5c7a510537dfd8c9d}{A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} {\bfseries operator/} (const \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} \&v0, float f)}\label{namespace_assimp_a7d888ec18cace2e5c7a510537dfd8c9d}

\item 
\hypertarget{namespace_assimp_aa0a4362d7b408d7dc867a74af2ab2f00}{A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} {\bfseries operator$\ast$} (float f, const \hyperlink{struct_assimp_1_1_m_d2_1_1_vertex}{Vertex} \&v0)}\label{namespace_assimp_aa0a4362d7b408d7dc867a74af2ab2f00}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Helper structures for the Collada loader

Defines the collada loader class

M\+A\+C\+H\+I\+N\+E-\/\+G\+E\+N\+E\+R\+A\+T\+E\+D by scripts/\+I\+C\+F\+Importer/\+Cpp\+Generator.\+py

\begin{DoxyNote}{Note}
Parts of this implementation, for example enums, deserialization constants and logic has been copied directly with minor modifications from the M\+I\+T licensed Ogre3\+D code base. See more from \href{https://bitbucket.org/sinbad/ogre}{\tt https\+://bitbucket.\+org/sinbad/ogre}.
\end{DoxyNote}
Implement shared utility functions for postprocessing steps

Small helper classes to optimise finding vertizes close to a given location

\hyperlink{class_assimp}{Assimp}'s C\+P\+P-\/\+A\+P\+I and all internal A\+P\+Is 

\subsection{Function Documentation}
\hypertarget{namespace_assimp_a4bd560c5925177fe3db8c0ef39338b17}{\index{Assimp@{Assimp}!Array\+Bounds@{Array\+Bounds}}
\index{Array\+Bounds@{Array\+Bounds}!Assimp@{Assimp}}
\subsubsection[{Array\+Bounds}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void Assimp\+::\+Array\+Bounds (
\begin{DoxyParamCaption}
\item[{const T $\ast$}]{in, }
\item[{unsigned int}]{size, }
\item[{T \&}]{min, }
\item[{T \&}]{max}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a4bd560c5925177fe3db8c0ef39338b17}


Find the min/max values of an array of Ts. 


\begin{DoxyParams}[1]{Parameters}
 & {\em in} & Input array \\
\hline
 & {\em size} & Numebr of elements to process \\
\hline
\mbox{\tt out}  & {\em min} & minimum value \\
\hline
\mbox{\tt out}  & {\em max} & maximum value \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a95de3dd4de6a42bfed3eb0a9fcea48be}{\index{Assimp@{Assimp}!A\+S\+S\+I\+M\+P\+\_\+itoa10@{A\+S\+S\+I\+M\+P\+\_\+itoa10}}
\index{A\+S\+S\+I\+M\+P\+\_\+itoa10@{A\+S\+S\+I\+M\+P\+\_\+itoa10}!Assimp@{Assimp}}
\subsubsection[{A\+S\+S\+I\+M\+P\+\_\+itoa10}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int Assimp\+::\+A\+S\+S\+I\+M\+P\+\_\+itoa10 (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{out, }
\item[{unsigned int}]{max, }
\item[{int32\+\_\+t}]{number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a95de3dd4de6a42bfed3eb0a9fcea48be}


itoa with a fixed base 10 'itoa' is not consistently available on all platforms so it is quite useful to have a small replacement function here. No need to use a full sprintf() if we just want to print a number ... 


\begin{DoxyParams}{Parameters}
{\em out} & Output buffer \\
\hline
{\em max} & Maximum number of characters to be written, including '\textbackslash{}0'. This parameter may not be 0. \\
\hline
{\em number} & Number to be written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Length of the output string, excluding the '\textbackslash{}0' 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a72851b2740829d0e26ee31da7af20ce6}{\index{Assimp@{Assimp}!A\+S\+S\+I\+M\+P\+\_\+stricmp@{A\+S\+S\+I\+M\+P\+\_\+stricmp}}
\index{A\+S\+S\+I\+M\+P\+\_\+stricmp@{A\+S\+S\+I\+M\+P\+\_\+stricmp}!Assimp@{Assimp}}
\subsubsection[{A\+S\+S\+I\+M\+P\+\_\+stricmp}]{\setlength{\rightskip}{0pt plus 5cm}int Assimp\+::\+A\+S\+S\+I\+M\+P\+\_\+stricmp (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a72851b2740829d0e26ee31da7af20ce6}


Helper function to do platform independent string comparison. 

This is required since stricmp() is not consistently available on all platforms. Some platforms use the '\+\_\+' prefix, others don't even have such a function.


\begin{DoxyParams}{Parameters}
{\em s1} & First input string \\
\hline
{\em s2} & Second input string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if the given strings are identical 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_abd7b0704eb33d941b05a778f916cf963}{\index{Assimp@{Assimp}!A\+S\+S\+I\+M\+P\+\_\+stricmp@{A\+S\+S\+I\+M\+P\+\_\+stricmp}}
\index{A\+S\+S\+I\+M\+P\+\_\+stricmp@{A\+S\+S\+I\+M\+P\+\_\+stricmp}!Assimp@{Assimp}}
\subsubsection[{A\+S\+S\+I\+M\+P\+\_\+stricmp}]{\setlength{\rightskip}{0pt plus 5cm}int Assimp\+::\+A\+S\+S\+I\+M\+P\+\_\+stricmp (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{a, }
\item[{const std\+::string \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_abd7b0704eb33d941b05a778f916cf963}


Case independent comparison of two std\+::strings. 


\begin{DoxyParams}{Parameters}
{\em a} & First string \\
\hline
{\em b} & Second string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if a == b 
\end{DoxyReturn}


Here is the call graph for this function\+:


\hypertarget{namespace_assimp_a5718d462fef0070afea1d4ac4e65d4d8}{\index{Assimp@{Assimp}!A\+S\+S\+I\+M\+P\+\_\+strincmp@{A\+S\+S\+I\+M\+P\+\_\+strincmp}}
\index{A\+S\+S\+I\+M\+P\+\_\+strincmp@{A\+S\+S\+I\+M\+P\+\_\+strincmp}!Assimp@{Assimp}}
\subsubsection[{A\+S\+S\+I\+M\+P\+\_\+strincmp}]{\setlength{\rightskip}{0pt plus 5cm}int Assimp\+::\+A\+S\+S\+I\+M\+P\+\_\+strincmp (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2, }
\item[{unsigned int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a5718d462fef0070afea1d4ac4e65d4d8}


Helper function to do platform independent string comparison. 

This is required since strincmp() is not consistently available on all platforms. Some platforms use the '\+\_\+' prefix, others don't even have such a function.


\begin{DoxyParams}{Parameters}
{\em s1} & First input string \\
\hline
{\em s2} & Second input string \\
\hline
{\em n} & Macimum number of characters to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if the given strings are identical 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a199e9276257039959c3a5d2110b36980}{\index{Assimp@{Assimp}!Compare\+Arrays@{Compare\+Arrays}}
\index{Compare\+Arrays@{Compare\+Arrays}!Assimp@{Assimp}}
\subsubsection[{Compare\+Arrays}]{\setlength{\rightskip}{0pt plus 5cm}bool Assimp\+::\+Compare\+Arrays (
\begin{DoxyParamCaption}
\item[{const {\bf ai\+Vector3\+D} $\ast$}]{first, }
\item[{const {\bf ai\+Vector3\+D} $\ast$}]{second, }
\item[{unsigned int}]{size, }
\item[{float}]{e}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a199e9276257039959c3a5d2110b36980}


Perform a component-\/wise comparison of two arrays. 


\begin{DoxyParams}{Parameters}
{\em first} & First array \\
\hline
{\em second} & Second aray \\
\hline
{\em size} & Size of both arrays \\
\hline
{\em e} & Epsilon \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the arrays are identical 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_aeec12ff2ff74693da249187a7c9f1fdd}{\index{Assimp@{Assimp}!Compute\+Material\+Hash@{Compute\+Material\+Hash}}
\index{Compute\+Material\+Hash@{Compute\+Material\+Hash}!Assimp@{Assimp}}
\subsubsection[{Compute\+Material\+Hash}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t Assimp\+::\+Compute\+Material\+Hash (
\begin{DoxyParamCaption}
\item[{const {\bf ai\+Material} $\ast$}]{mat, }
\item[{bool}]{include\+Mat\+Name = {\ttfamily false}}
\end{DoxyParamCaption}
)}}\label{namespace_assimp_aeec12ff2ff74693da249187a7c9f1fdd}
Computes a hash (hopefully unique) from all material properties The hash value reflects the current property state, so if you add any property and call this method again, the resulting hash value will be different. The hash is not persistent across different builds and platforms.


\begin{DoxyParams}{Parameters}
{\em include\+Mat\+Name} & Set to 'true' to take all properties with '?' as initial character in their name into account. Currently \#\+A\+I\+\_\+\+M\+A\+T\+K\+E\+Y\+\_\+\+N\+A\+M\+E is the only example. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
32 Bit jash value for the material 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a1427aee7ea9b613a4677c68d40d68b3b}{\index{Assimp@{Assimp}!Convert\+List\+To\+Strings@{Convert\+List\+To\+Strings}}
\index{Convert\+List\+To\+Strings@{Convert\+List\+To\+Strings}!Assimp@{Assimp}}
\subsubsection[{Convert\+List\+To\+Strings}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Convert\+List\+To\+Strings (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{in, }
\item[{std\+::list$<$ std\+::string $>$ \&}]{out}
\end{DoxyParamCaption}
)}}\label{namespace_assimp_a1427aee7ea9b613a4677c68d40d68b3b}


Extract single strings from a list of identifiers. 


\begin{DoxyParams}{Parameters}
{\em in} & Input string list. \\
\hline
{\em out} & Receives a list of clean output strings  \#\+A\+I\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+P\+P\+\_\+\+O\+G\+\_\+\+E\+X\+C\+L\+U\+D\+E\+\_\+\+L\+I\+S\+T \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a9fa5e810cd3a03f8f0b9b232a9c2adb9}{\index{Assimp@{Assimp}!Copy\+Next\+Word@{Copy\+Next\+Word}}
\index{Copy\+Next\+Word@{Copy\+Next\+Word}!Assimp@{Assimp}}
\subsubsection[{Copy\+Next\+Word}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class char\+\_\+t $>$ char\+\_\+t Assimp\+::\+Copy\+Next\+Word (
\begin{DoxyParamCaption}
\item[{char\+\_\+t}]{it, }
\item[{char\+\_\+t}]{end, }
\item[{char $\ast$}]{p\+Buffer, }
\item[{size\+\_\+t}]{length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a9fa5e810cd3a03f8f0b9b232a9c2adb9}


Get next word from given line. 


\begin{DoxyParams}{Parameters}
{\em it} & set to current position \\
\hline
{\em end} & set to end of scratch buffer for readout \\
\hline
{\em p\+Buffer} & Buffer for next word \\
\hline
{\em length} & Buffer length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Current-\/iterator with new position 
\end{DoxyReturn}


Here is the call graph for this function\+:


\hypertarget{namespace_assimp_a99179da009833bb3b0b72b469edf6370}{\index{Assimp@{Assimp}!fast\+\_\+atoreal\+\_\+move@{fast\+\_\+atoreal\+\_\+move}}
\index{fast\+\_\+atoreal\+\_\+move@{fast\+\_\+atoreal\+\_\+move}!Assimp@{Assimp}}
\subsubsection[{fast\+\_\+atoreal\+\_\+move}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Real $>$ const char$\ast$ Assimp\+::fast\+\_\+atoreal\+\_\+move (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{c, }
\item[{Real \&}]{out, }
\item[{bool}]{check\+\_\+comma = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a99179da009833bb3b0b72b469edf6370}
Provides a fast function for converting a string into a float, about 6 times faster than atof in win32. \hypertarget{namespace_assimp_a40d018d9f497377fa37b58d7c7cb1e56}{\index{Assimp@{Assimp}!Find\+A\+A\+B\+B\+Transformed@{Find\+A\+A\+B\+B\+Transformed}}
\index{Find\+A\+A\+B\+B\+Transformed@{Find\+A\+A\+B\+B\+Transformed}!Assimp@{Assimp}}
\subsubsection[{Find\+A\+A\+B\+B\+Transformed}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Find\+A\+A\+B\+B\+Transformed (
\begin{DoxyParamCaption}
\item[{const {\bf ai\+Mesh} $\ast$}]{mesh, }
\item[{{\bf ai\+Vector3\+D} \&}]{min, }
\item[{{\bf ai\+Vector3\+D} \&}]{max, }
\item[{const {\bf ai\+Matrix4x4} \&}]{m}
\end{DoxyParamCaption}
)}}\label{namespace_assimp_a40d018d9f497377fa37b58d7c7cb1e56}


Compute the \hyperlink{class_a_a_b_b}{A\+A\+B\+B} of a mesh after applying a given transform. 


\begin{DoxyParams}[1]{Parameters}
 & {\em mesh} & Input mesh \\
\hline
\mbox{\tt out}  & {\em min} & Receives minimum transformed vertex \\
\hline
\mbox{\tt out}  & {\em max} & Receives maximum transformed vertex \\
\hline
 & {\em m} & Transformation matrix to be applied \\
\hline
\end{DoxyParams}
\hypertarget{namespace_assimp_a4cccef1c4b037b4eda69f9955fe614b4}{\index{Assimp@{Assimp}!Find\+Mesh\+Center@{Find\+Mesh\+Center}}
\index{Find\+Mesh\+Center@{Find\+Mesh\+Center}!Assimp@{Assimp}}
\subsubsection[{Find\+Mesh\+Center}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Find\+Mesh\+Center (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Mesh} $\ast$}]{mesh, }
\item[{{\bf ai\+Vector3\+D} \&}]{out, }
\item[{{\bf ai\+Vector3\+D} \&}]{min, }
\item[{{\bf ai\+Vector3\+D} \&}]{max}
\end{DoxyParamCaption}
)}}\label{namespace_assimp_a4cccef1c4b037b4eda69f9955fe614b4}


Helper function to determine the 'real' center of a mesh. 

That is the center of its axis-\/aligned bounding box. 
\begin{DoxyParams}[1]{Parameters}
 & {\em mesh} & Input mesh \\
\hline
\mbox{\tt out}  & {\em min} & Minimum vertex of the mesh \\
\hline
\mbox{\tt out}  & {\em max} & maximum vertex of the mesh \\
\hline
\mbox{\tt out}  & {\em out} & Center point \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_af60598b5a7161a8c918b65fea426c08d}{\index{Assimp@{Assimp}!Get\+Area2\+D@{Get\+Area2\+D}}
\index{Get\+Area2\+D@{Get\+Area2\+D}!Assimp@{Assimp}}
\subsubsection[{Get\+Area2\+D}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ double Assimp\+::\+Get\+Area2\+D (
\begin{DoxyParamCaption}
\item[{const T \&}]{v1, }
\item[{const T \&}]{v2, }
\item[{const T \&}]{v3}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_af60598b5a7161a8c918b65fea426c08d}
Compute the signed area of a triangle. The function accepts an unconstrained template parameter for use with both \hyperlink{structai_vector3_d}{ai\+Vector3\+D} and \hyperlink{structai_vector2_d}{ai\+Vector2\+D}, but generally ignores the third coordinate. 

Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a19ad49cb7574ea17c7bc1e9376cac0fa}{\index{Assimp@{Assimp}!Get\+Color\+Difference@{Get\+Color\+Difference}}
\index{Get\+Color\+Difference@{Get\+Color\+Difference}!Assimp@{Assimp}}
\subsubsection[{Get\+Color\+Difference}]{\setlength{\rightskip}{0pt plus 5cm}float Assimp\+::\+Get\+Color\+Difference (
\begin{DoxyParamCaption}
\item[{const {\bf ai\+Color4\+D} \&}]{p\+Color1, }
\item[{const {\bf ai\+Color4\+D} \&}]{p\+Color2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a19ad49cb7574ea17c7bc1e9376cac0fa}
Little helper function to calculate the quadratic difference of two colours. 
\begin{DoxyParams}{Parameters}
{\em p\+Color1} & First color \\
\hline
{\em p\+Color2} & second color \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Quadratic color difference 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a3a64f936048746e10d0aa50e3eee9099}{\index{Assimp@{Assimp}!get\+Float@{get\+Float}}
\index{get\+Float@{get\+Float}!Assimp@{Assimp}}
\subsubsection[{get\+Float}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class char\+\_\+t $>$ char\+\_\+t Assimp\+::get\+Float (
\begin{DoxyParamCaption}
\item[{char\+\_\+t}]{it, }
\item[{char\+\_\+t}]{end, }
\item[{float \&}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a3a64f936048746e10d0aa50e3eee9099}


Get next float from given line. 


\begin{DoxyParams}{Parameters}
{\em it} & set to current position \\
\hline
{\em end} & set to end of scratch buffer for readout \\
\hline
{\em value} & Separated float value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Current-\/iterator with new position 
\end{DoxyReturn}
\hypertarget{namespace_assimp_aa55ce1d958f3732c90f748b2e7d44293}{\index{Assimp@{Assimp}!Get\+Mesh\+Hash@{Get\+Mesh\+Hash}}
\index{Get\+Mesh\+Hash@{Get\+Mesh\+Hash}!Assimp@{Assimp}}
\subsubsection[{Get\+Mesh\+Hash}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t Assimp\+::\+Get\+Mesh\+Hash (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Mesh} $\ast$}]{in}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_aa55ce1d958f3732c90f748b2e7d44293}


Get a pseudo(!)-\/hash representing a mesh. 

The hash is built from number of vertices, faces, primitive types, .... but {\itshape not} from the real mesh data. The funcction is not a perfect hash. 
\begin{DoxyParams}{Parameters}
{\em in} & Input mesh \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{struct_hash}{Hash}. 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a0f8daeb06b4e861a2152c33413e6eae1}{\index{Assimp@{Assimp}!get\+Name@{get\+Name}}
\index{get\+Name@{get\+Name}!Assimp@{Assimp}}
\subsubsection[{get\+Name}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class char\+\_\+t $>$ char\+\_\+t Assimp\+::get\+Name (
\begin{DoxyParamCaption}
\item[{char\+\_\+t}]{it, }
\item[{char\+\_\+t}]{end, }
\item[{std\+::string \&}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a0f8daeb06b4e861a2152c33413e6eae1}


Get a name from the current line. Preserve space in the middle, but trim it at the end. 


\begin{DoxyParams}{Parameters}
{\em it} & set to current position \\
\hline
{\em end} & set to end of scratch buffer for readout \\
\hline
{\em name} & Separated name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Current-\/iterator with new position 
\end{DoxyReturn}


Here is the call graph for this function\+:


\hypertarget{namespace_assimp_ada8c8de6132e8d219622b325f3109607}{\index{Assimp@{Assimp}!get\+Next\+Token@{get\+Next\+Token}}
\index{get\+Next\+Token@{get\+Next\+Token}!Assimp@{Assimp}}
\subsubsection[{get\+Next\+Token}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Char\+\_\+\+T $>$ Char\+\_\+\+T Assimp\+::get\+Next\+Token (
\begin{DoxyParamCaption}
\item[{Char\+\_\+\+T}]{p\+Buffer, }
\item[{Char\+\_\+\+T}]{p\+End}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_ada8c8de6132e8d219622b325f3109607}


Returns pointer a next token. 


\begin{DoxyParams}{Parameters}
{\em p\+Buffer} & Pointer to data buffer \\
\hline
{\em p\+End} & Pointer to end of buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to next token 
\end{DoxyReturn}


Here is the call graph for this function\+:


\hypertarget{namespace_assimp_a136ee23a615c5889f37d4e22ec7a343a}{\index{Assimp@{Assimp}!get\+Next\+Word@{get\+Next\+Word}}
\index{get\+Next\+Word@{get\+Next\+Word}!Assimp@{Assimp}}
\subsubsection[{get\+Next\+Word}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Char\+\_\+\+T $>$ Char\+\_\+\+T Assimp\+::get\+Next\+Word (
\begin{DoxyParamCaption}
\item[{Char\+\_\+\+T}]{p\+Buffer, }
\item[{Char\+\_\+\+T}]{p\+End}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a136ee23a615c5889f37d4e22ec7a343a}


Returns next word separated by a space. 


\begin{DoxyParams}{Parameters}
{\em p\+Buffer} & Pointer to data buffer \\
\hline
{\em p\+End} & Pointer to end of buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to next space 
\end{DoxyReturn}


Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a7f1165ac9e907c30dbbba7657c651b4e}{\index{Assimp@{Assimp}!integer\+\_\+pow@{integer\+\_\+pow}}
\index{integer\+\_\+pow@{integer\+\_\+pow}!Assimp@{Assimp}}
\subsubsection[{integer\+\_\+pow}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int Assimp\+::integer\+\_\+pow (
\begin{DoxyParamCaption}
\item[{unsigned int}]{base, }
\item[{unsigned int}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a7f1165ac9e907c30dbbba7657c651b4e}


Evaluates an integer power. 

todo\+: move somewhere where it fits better in than here 

Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a8d01c8219b0bc01a2ecf0012ed671889}{\index{Assimp@{Assimp}!Is\+C\+C\+W@{Is\+C\+C\+W}}
\index{Is\+C\+C\+W@{Is\+C\+C\+W}!Assimp@{Assimp}}
\subsubsection[{Is\+C\+C\+W}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool Assimp\+::\+Is\+C\+C\+W (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{in, }
\item[{size\+\_\+t}]{npoints}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a8d01c8219b0bc01a2ecf0012ed671889}
Check whether the winding order of a given polygon is counter-\/clockwise. The function accepts an unconstrained template parameter, but is intended to be used only with \hyperlink{structai_vector2_d}{ai\+Vector2\+D} and \hyperlink{structai_vector3_d}{ai\+Vector3\+D} (z axis is ignored, only x and y are taken into account). \begin{DoxyNote}{Note}
Code taken from \href{http://cgm.cs.mcgill.ca/~godfried/teaching/cg-projects/97/Ian/applet1.html}{\tt http\+://cgm.\+cs.\+mcgill.\+ca/$\sim$godfried/teaching/cg-\/projects/97/\+Ian/applet1.\+html} and translated to C++ 
\end{DoxyNote}


Here is the call graph for this function\+:


\hypertarget{namespace_assimp_a98cbb5f7f096bb5e6b42e08d4f65456a}{\index{Assimp@{Assimp}!is\+End\+Of\+Buffer@{is\+End\+Of\+Buffer}}
\index{is\+End\+Of\+Buffer@{is\+End\+Of\+Buffer}!Assimp@{Assimp}}
\subsubsection[{is\+End\+Of\+Buffer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class char\+\_\+t $>$ bool Assimp\+::is\+End\+Of\+Buffer (
\begin{DoxyParamCaption}
\item[{char\+\_\+t}]{it, }
\item[{char\+\_\+t}]{end}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a98cbb5f7f096bb5e6b42e08d4f65456a}


Returns true, if the last entry of the buffer is reached. 


\begin{DoxyParams}{Parameters}
{\em it} & Iterator of current position. \\
\hline
{\em end} & Iterator with end of buffer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true, if the end of the buffer is reached. 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a85a3905e1425845270407c4b081fa02f}{\index{Assimp@{Assimp}!is\+New\+Line@{is\+New\+Line}}
\index{is\+New\+Line@{is\+New\+Line}!Assimp@{Assimp}}
\subsubsection[{is\+New\+Line}]{\setlength{\rightskip}{0pt plus 5cm}bool Assimp\+::is\+New\+Line (
\begin{DoxyParamCaption}
\item[{char}]{token}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a85a3905e1425845270407c4b081fa02f}


Returns true, fi token id a new line marking token. 


\begin{DoxyParams}{Parameters}
{\em token} & \hyperlink{struct_token}{Token} to search in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true, if token is a newline token. 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_ac0fa4924a9d69a0c625c44af70de4793}{\index{Assimp@{Assimp}!is\+Separator@{is\+Separator}}
\index{is\+Separator@{is\+Separator}!Assimp@{Assimp}}
\subsubsection[{is\+Separator}]{\setlength{\rightskip}{0pt plus 5cm}bool Assimp\+::is\+Separator (
\begin{DoxyParamCaption}
\item[{char}]{token}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_ac0fa4924a9d69a0c625c44af70de4793}


Returns true, if token is a space on any supported platform. 


\begin{DoxyParams}{Parameters}
{\em token} & \hyperlink{struct_token}{Token} to search in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true, if token is a space 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_af542a87f4818ee15b1ee8bd25c480d82}{\index{Assimp@{Assimp}!Newell\+Normal@{Newell\+Normal}}
\index{Newell\+Normal@{Newell\+Normal}!Assimp@{Assimp}}
\subsubsection[{Newell\+Normal}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int ofs\+\_\+x, int ofs\+\_\+y, int ofs\+\_\+z, typename T\+Real $>$ void Assimp\+::\+Newell\+Normal (
\begin{DoxyParamCaption}
\item[{ai\+Vector3t$<$ T\+Real $>$ \&}]{out, }
\item[{int}]{num, }
\item[{T\+Real $\ast$}]{x, }
\item[{T\+Real $\ast$}]{y, }
\item[{T\+Real $\ast$}]{z}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_af542a87f4818ee15b1ee8bd25c480d82}
Compute the normal of an arbitrary polygon in R3.

The code is based on Newell's formula, that is a polygons normal is the ratio of its area when projected onto the three coordinate axes.


\begin{DoxyParams}{Parameters}
{\em out} & Receives the output normal \\
\hline
{\em num} & Number of input vertices \\
\hline
{\em x} & X data source. x\mbox{[}ofs\+\_\+x$\ast$n\mbox{]} is the n'th element. \\
\hline
{\em y} & Y data source. y\mbox{[}ofs\+\_\+y$\ast$n\mbox{]} is the y'th element \\
\hline
{\em z} & Z data source. z\mbox{[}ofs\+\_\+z$\ast$n\mbox{]} is the z'th element\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The data arrays must have storage for at least num+2 elements. Using this method is much faster than the 'other' \hyperlink{namespace_assimp_af542a87f4818ee15b1ee8bd25c480d82}{Newell\+Normal()} 
\end{DoxyNote}
\hypertarget{namespace_assimp_a8befcf1030197c725d93b98d558bec85}{\index{Assimp@{Assimp}!On\+Left\+Side\+Of\+Line2\+D@{On\+Left\+Side\+Of\+Line2\+D}}
\index{On\+Left\+Side\+Of\+Line2\+D@{On\+Left\+Side\+Of\+Line2\+D}!Assimp@{Assimp}}
\subsubsection[{On\+Left\+Side\+Of\+Line2\+D}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool Assimp\+::\+On\+Left\+Side\+Of\+Line2\+D (
\begin{DoxyParamCaption}
\item[{const T \&}]{p0, }
\item[{const T \&}]{p1, }
\item[{const T \&}]{p2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a8befcf1030197c725d93b98d558bec85}
\hyperlink{class_test}{Test} if a given point p2 is on the left side of the line formed by p0-\/p1. The function accepts an unconstrained template parameter for use with both \hyperlink{structai_vector3_d}{ai\+Vector3\+D} and \hyperlink{structai_vector2_d}{ai\+Vector2\+D}, but generally ignores the third coordinate. 

Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_adfc6439fa2efcc68e6e1591411dc3ab8}{\index{Assimp@{Assimp}!Point\+In\+Triangle2\+D@{Point\+In\+Triangle2\+D}}
\index{Point\+In\+Triangle2\+D@{Point\+In\+Triangle2\+D}!Assimp@{Assimp}}
\subsubsection[{Point\+In\+Triangle2\+D}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool Assimp\+::\+Point\+In\+Triangle2\+D (
\begin{DoxyParamCaption}
\item[{const T \&}]{p0, }
\item[{const T \&}]{p1, }
\item[{const T \&}]{p2, }
\item[{const T \&}]{pp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_adfc6439fa2efcc68e6e1591411dc3ab8}
\hyperlink{class_test}{Test} if a given point is inside a given triangle in R2. The function accepts an unconstrained template parameter for use with both \hyperlink{structai_vector3_d}{ai\+Vector3\+D} and \hyperlink{structai_vector2_d}{ai\+Vector2\+D}, but generally ignores the third coordinate. 

Here is the caller graph for this function\+:


\hypertarget{namespace_assimp_a70862408fff68ee98076ad089ee1ae7b}{\index{Assimp@{Assimp}!skip\+Line@{skip\+Line}}
\index{skip\+Line@{skip\+Line}!Assimp@{Assimp}}
\subsubsection[{skip\+Line}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class char\+\_\+t $>$ char\+\_\+t Assimp\+::skip\+Line (
\begin{DoxyParamCaption}
\item[{char\+\_\+t}]{it, }
\item[{char\+\_\+t}]{end, }
\item[{unsigned int \&}]{ui\+Line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{namespace_assimp_a70862408fff68ee98076ad089ee1ae7b}


Skips a line. 


\begin{DoxyParams}{Parameters}
{\em it} & Iterator set to current position \\
\hline
{\em end} & Iterator set to end of scratch buffer for readout \\
\hline
{\em ui\+Line} & Current linenumber in format \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Current-\/iterator with new position 
\end{DoxyReturn}


Here is the call graph for this function\+:


\hypertarget{namespace_assimp_add92ce34a50273a4d925ec78a7fc658a}{\index{Assimp@{Assimp}!tokenize@{tokenize}}
\index{tokenize@{tokenize}!Assimp@{Assimp}}
\subsubsection[{tokenize}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class string\+\_\+type $>$ unsigned int Assimp\+::tokenize (
\begin{DoxyParamCaption}
\item[{const string\+\_\+type \&}]{str, }
\item[{std\+::vector$<$ string\+\_\+type $>$ \&}]{tokens, }
\item[{const string\+\_\+type \&}]{delimiters}
\end{DoxyParamCaption}
)}}\label{namespace_assimp_add92ce34a50273a4d925ec78a7fc658a}


Will perform a simple tokenize. 


\begin{DoxyParams}{Parameters}
{\em str} & String to tokenize. \\
\hline
{\em tokens} & Array with tokens, will be empty if no token was found. \\
\hline
{\em delimiters} & Delimiter for tokenize. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of found token. 
\end{DoxyReturn}
\hypertarget{namespace_assimp_a3bd333f65bd8da9590190ed27987e47f}{\index{Assimp@{Assimp}!Token\+Match\+I@{Token\+Match\+I}}
\index{Token\+Match\+I@{Token\+Match\+I}!Assimp@{Assimp}}
\subsubsection[{Token\+Match\+I}]{\setlength{\rightskip}{0pt plus 5cm}A\+I\+\_\+\+F\+O\+R\+C\+E\+\_\+\+I\+N\+L\+I\+N\+E bool Assimp\+::\+Token\+Match\+I (
\begin{DoxyParamCaption}
\item[{const char $\ast$\&}]{in, }
\item[{const char $\ast$}]{token, }
\item[{unsigned int}]{len}
\end{DoxyParamCaption}
)}}\label{namespace_assimp_a3bd333f65bd8da9590190ed27987e47f}


Case-\/ignoring version of Token\+Match. 


\begin{DoxyParams}{Parameters}
{\em in} & Input \\
\hline
{\em token} & \hyperlink{struct_token}{Token} to check for \\
\hline
{\em len} & Number of characters to check \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:




Here is the caller graph for this function\+:


