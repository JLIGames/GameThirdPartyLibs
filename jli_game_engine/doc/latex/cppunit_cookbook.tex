Here is a short cookbook to help you get started.\hypertarget{cppunit_cookbook_simple_test_case}{}\section{Simple Test Case}\label{cppunit_cookbook_simple_test_case}
You want to know whether your code is working.

How do you do it?

There are many ways. Stepping through a debugger or littering your code with stream output calls are two of the simpler ways, but they both have drawbacks. Stepping through your code is a good idea, but it is not automatic. You have to do it every time you make changes. Streaming out text is also fine, but it makes code ugly and it generates far more information than you need most of the time.

Tests in Cpp\+Unit can be run automatically. They are easy to set up and once you have written them, they are always there to help you keep confidence in the quality of your code.

To make a simple test, here is what you do\+:

Subclass the \hyperlink{}{Test\+Case } class. Override the method \hyperlink{}{run\+Test()}. When you want to check a value, call \hyperlink{}{C\+P\+P\+U\+N\+I\+T\+\_\+\+A\+S\+S\+E\+R\+T(bool) } and pass in an expression that is true if the test succeeds.

For example, to test the equality comparison for a Complex number class, write\+:


\begin{DoxyCode}
\textcolor{keyword}{class }ComplexNumberTest : \textcolor{keyword}{public} CppUnit::TestCase \{ 
\textcolor{keyword}{public}: 
  ComplexNumberTest( std::string name ) : CppUnit::\hyperlink{class_test_case}{TestCase}( name ) \{\}
  
  \textcolor{keywordtype}{void} runTest() \{
    CPPUNIT\_ASSERT( Complex (10, 1) == Complex (10, 1) );
    CPPUNIT\_ASSERT( !(Complex (1, 1) == Complex (2, 2)) );
  \}
\};
\end{DoxyCode}


That was a very simple test. Ordinarily, you'll have many little test cases that you'll want to run on the same set of objects. To do this, use a fixture.\hypertarget{cppunit_cookbook_fixture}{}\section{Fixture}\label{cppunit_cookbook_fixture}
A fixture is a known set of objects that serves as a base for a set of test cases. Fixtures come in very handy when you are testing as you develop.

Let's try out this style of development and learn about fixtures along the away. Suppose that we are really developing a complex number class. Let's start by defining a empty class named Complex.


\begin{DoxyCode}
\textcolor{keyword}{class }Complex \{\};
\end{DoxyCode}


Now create an instance of Complex\+Number\+Test above, compile the code and see what happens. The first thing we notice is a few compiler errors. The test uses {\ttfamily operator ==}, but it is not defined. Let's fix that.


\begin{DoxyCode}
\textcolor{keywordtype}{bool} \hyperlink{group___a_p_i___o_g_l_e_s2_ga8425a5ca2f4117542f2cb1c12ded2236}{operator==}( \textcolor{keyword}{const} Complex &a, \textcolor{keyword}{const} Complex &b) 
\{ 
  \textcolor{keywordflow}{return} \textcolor{keyword}{true}; 
\}
\end{DoxyCode}


Now compile the test, and run it. This time it compiles but the test fails. We need a bit more to get an {\ttfamily operator ==}working correctly, so we revisit the code.


\begin{DoxyCode}
\textcolor{keyword}{class }Complex \{ 
  \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} \hyperlink{group___a_p_i___o_g_l_e_s2_ga8425a5ca2f4117542f2cb1c12ded2236}{operator ==}(\textcolor{keyword}{const} Complex& a, \textcolor{keyword}{const} Complex& b);
  \textcolor{keywordtype}{double} real, imaginary;
\textcolor{keyword}{public}:
  Complex( \textcolor{keywordtype}{double} r, \textcolor{keywordtype}{double} i = 0 ) 
    : real(r)
    , imaginary(i) 
  \{
  \}
\};

\textcolor{keywordtype}{bool} \hyperlink{group___a_p_i___o_g_l_e_s2_ga8425a5ca2f4117542f2cb1c12ded2236}{operator ==}( \textcolor{keyword}{const} Complex &a, \textcolor{keyword}{const} Complex &b )
\{ 
  \textcolor{keywordflow}{return} a.real == b.real  &&  a.imaginary == b.imaginary; 
\}
\end{DoxyCode}


If we compile now and run our test it will pass.

Now we are ready to add new operations and new tests. At this point a fixture would be handy. We would probably be better off when doing our tests if we decided to instantiate three or four complex numbers and reuse them across our tests.

Here is how we do it\+:
\begin{DoxyItemize}
\item Add member variables for each part of the \hyperlink{}{fixture }
\item Override \hyperlink{}{set\+Up() } to initialize the variables
\item Override \hyperlink{}{tear\+Down() } to release any permanent resources you allocated in \hyperlink{}{set\+Up() }
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{class }ComplexNumberTest : \textcolor{keyword}{public} CppUnit::TestFixture \{
\textcolor{keyword}{private}:
  Complex *m\_10\_1, *m\_1\_1, *m\_11\_2;
\textcolor{keyword}{public}:
  \textcolor{keywordtype}{void} setUp()
  \{
    m\_10\_1 = \textcolor{keyword}{new} Complex( 10, 1 );
    m\_1\_1 = \textcolor{keyword}{new} Complex( 1, 1 );
    m\_11\_2 = \textcolor{keyword}{new} Complex( 11, 2 );  
  \}

  \textcolor{keywordtype}{void} tearDown() 
  \{
    \textcolor{keyword}{delete} m\_10\_1;
    \textcolor{keyword}{delete} m\_1\_1;
    \textcolor{keyword}{delete} m\_11\_2;
  \}
\};
\end{DoxyCode}


Once we have this fixture, we can add the complex addition test case and any others that we need over the course of our development.\hypertarget{cppunit_cookbook_test_case}{}\section{Test Case}\label{cppunit_cookbook_test_case}
How do you write and invoke individual tests using a fixture?

There are two steps to this process\+:
\begin{DoxyItemize}
\item Write the test case as a method in the fixture class
\item Create a \hyperlink{class_test_caller}{Test\+Caller} which runs that particular method
\end{DoxyItemize}

Here is our test case class with a few extra case methods\+:


\begin{DoxyCode}
\textcolor{keyword}{class }ComplexNumberTest : \textcolor{keyword}{public} CppUnit::TestFixture  \{
\textcolor{keyword}{private}:
  Complex *m\_10\_1, *m\_1\_1, *m\_11\_2;
\textcolor{keyword}{public}:
  \textcolor{keywordtype}{void} setUp()
  \{
    m\_10\_1 = \textcolor{keyword}{new} Complex( 10, 1 );
    m\_1\_1 = \textcolor{keyword}{new} Complex( 1, 1 );
    m\_11\_2 = \textcolor{keyword}{new} Complex( 11, 2 );  
  \}

  \textcolor{keywordtype}{void} tearDown() 
  \{
    \textcolor{keyword}{delete} m\_10\_1;
    \textcolor{keyword}{delete} m\_1\_1;
    \textcolor{keyword}{delete} m\_11\_2;
  \}

  \textcolor{keywordtype}{void} testEquality()
  \{
    CPPUNIT\_ASSERT( *m\_10\_1 == *m\_10\_1 );
    CPPUNIT\_ASSERT( !(*m\_10\_1 == *m\_11\_2) );
  \}

  \textcolor{keywordtype}{void} testAddition()
  \{
    CPPUNIT\_ASSERT( *m\_10\_1 + *m\_1\_1 == *m\_11\_2 );
  \}
\};
\end{DoxyCode}


One may create and run instances for each test case like this\+:


\begin{DoxyCode}
CppUnit::TestCaller<ComplexNumberTest> test( \textcolor{stringliteral}{"testEquality"}, 
                                             &ComplexNumberTest::testEquality );
CppUnit::TestResult result;
test.run( &result );
\end{DoxyCode}


The second argument to the test caller constructor is the address of a method on Complex\+Number\+Test. When the test caller is run, that specific method will be run. This is not a useful thing to do, however, as no diagnostics will be displayed. One will normally use a \hyperlink{group___executing_test}{Test\+Runner } (see below) to display the results.

Once you have several tests, organize them into a suite.\hypertarget{cppunit_cookbook_suite}{}\section{Suite}\label{cppunit_cookbook_suite}
How do you set up your tests so that you can run them all at once?

Cpp\+Unit provides a \hyperlink{}{Test\+Suite } class that runs any number of Test\+Cases together.

We saw, above, how to run a single test case.

To create a suite of two or more tests, you do the following\+:


\begin{DoxyCode}
CppUnit::TestSuite suite;
CppUnit::TestResult result;
suite.addTest( \textcolor{keyword}{new} CppUnit::TestCaller<ComplexNumberTest>(
                       \textcolor{stringliteral}{"testEquality"}, 
                       &ComplexNumberTest::testEquality ) );
suite.addTest( \textcolor{keyword}{new} CppUnit::TestCaller<ComplexNumberTest>(
                       \textcolor{stringliteral}{"testAddition"}, 
                       &ComplexNumberTest::testAddition ) );
suite.run( &result );
\end{DoxyCode}


\hyperlink{}{Test\+Suites } don't only have to contain callers for Test\+Cases. They can contain any object that implements the \hyperlink{}{Test } interface. For example, you can create a \hyperlink{}{Test\+Suite } in your code and I can create one in mine, and we can run them together by creating a \hyperlink{}{Test\+Suite } that contains both\+:


\begin{DoxyCode}
CppUnit::TestSuite suite;
CppUnit::TestResult result;
suite.addTest( ComplexNumberTest::suite() );
suite.addTest( SurrealNumberTest::suite() );
suite.run( &result );
\end{DoxyCode}
\hypertarget{cppunit_cookbook_test_runner}{}\section{Test\+Runner}\label{cppunit_cookbook_test_runner}
How do you run your tests and collect their results?

Once you have a test suite, you'll want to run it. Cpp\+Unit provides tools to define the suite to be run and to display its results. You make your suite accessible to a \hyperlink{group___executing_test}{Test\+Runner } program with a static method {\itshape suite} that returns a test suite.

For example, to make a Complex\+Number\+Test suite available to a \hyperlink{group___executing_test}{Test\+Runner }, add the following code to Complex\+Number\+Test\+:


\begin{DoxyCode}
\textcolor{keyword}{public}: 
  \textcolor{keyword}{static} CppUnit::TestSuite *suite()
  \{
    CppUnit::TestSuite *suiteOfTests = \textcolor{keyword}{new} CppUnit::TestSuite( \textcolor{stringliteral}{"ComplexNumberTest"} );
    suiteOfTests->addTest( \textcolor{keyword}{new} CppUnit::TestCaller<ComplexNumberTest>( 
                                   \textcolor{stringliteral}{"testEquality"}, 
                                   &ComplexNumberTest::testEquality ) );
    suiteOfTests->addTest( \textcolor{keyword}{new} CppUnit::TestCaller<ComplexNumberTest>(
                                   \textcolor{stringliteral}{"testAddition"},
                                   &ComplexNumberTest::testAddition ) );
    \textcolor{keywordflow}{return} suiteOfTests;
  \}
\end{DoxyCode}


\label{cppunit_cookbook_test_runner_code}%
\hypertarget{cppunit_cookbook_test_runner_code}{}%
To use the text version, include the header files for the tests in Main.\+cpp\+:


\begin{DoxyCode}
\textcolor{preprocessor}{#include <cppunit/ui/text/TestRunner.h>}
\textcolor{preprocessor}{#include "ExampleTestCase.h"}
\textcolor{preprocessor}{#include "ComplexNumberTest.h"}
\end{DoxyCode}


And add a call to \hyperlink{}{add\+Test(\+Cpp\+Unit\+::\+Test $\ast$) } in the {\ttfamily main()} function\+:


\begin{DoxyCode}
\textcolor{keywordtype}{int} main( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
  CppUnit::TextUi::TestRunner runner;
  runner.addTest( ExampleTestCase::suite() );
  runner.addTest( ComplexNumberTest::suite() );
  runner.run();
  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


The \hyperlink{group___executing_test}{Test\+Runner } will run the tests. If all the tests pass, you'll get an informative message. If any fail, you'll get the following information\+:


\begin{DoxyItemize}
\item The name of the test case that failed
\item The name of the source file that contains the test
\item The line number where the failure occurred
\item All of the text inside the call to C\+P\+P\+U\+N\+I\+T\+\_\+\+A\+S\+S\+E\+R\+T() which detected the failure
\end{DoxyItemize}

Cpp\+Unit distinguishes between {\itshape failures} and {\itshape errors}. A failure is anticipated and checked for with assertions. Errors are unanticipated problems like division by zero and other exceptions thrown by the C++ runtime or your code.\hypertarget{cppunit_cookbook_helper_macros}{}\section{Helper Macros}\label{cppunit_cookbook_helper_macros}
As you might have noticed, implementing the fixture static {\ttfamily suite()} method is a repetitive and error prone task. A \hyperlink{group___writing_test_fixture}{Writing test fixture} set of macros have been created to automatically implements the static {\ttfamily suite()} method.

The following code is a rewrite of Complex\+Number\+Test using those macros\+:


\begin{DoxyCode}
\textcolor{preprocessor}{#include <cppunit/extensions/HelperMacros.h>}

\textcolor{keyword}{class }ComplexNumberTest : \textcolor{keyword}{public} CppUnit::TestFixture  \{
\end{DoxyCode}
 First, we declare the suite, passing the class name to the macro\+: 
\begin{DoxyCode}
\hyperlink{group___writing_test_fixture_gabe1e12200f40d6f25d60c1783c99da81}{CPPUNIT\_TEST\_SUITE}( ComplexNumberTest );
\end{DoxyCode}
 The suite created by the static {\ttfamily suite()} method is named after the class name. Then, we declare each test case of the fixture\+: 
\begin{DoxyCode}
\hyperlink{group___writing_test_fixture_gaac9b03d898b207e1daf2f93867935a96}{CPPUNIT\_TEST}( testEquality );
\hyperlink{group___writing_test_fixture_gaac9b03d898b207e1daf2f93867935a96}{CPPUNIT\_TEST}( testAddition );
\end{DoxyCode}
 Finally, we end the suite declaration\+: 
\begin{DoxyCode}
\hyperlink{group___writing_test_fixture_ga601b2e1d525f3947b216e28c625abcb1}{CPPUNIT\_TEST\_SUITE\_END}();
\end{DoxyCode}
 At this point, a method with the following signature has been implemented\+: 
\begin{DoxyCode}
\textcolor{keyword}{static} CppUnit::TestSuite *suite();
\end{DoxyCode}
 The rest of the fixture is left unchanged\+: 
\begin{DoxyCode}
\textcolor{keyword}{private}:
  Complex *m\_10\_1, *m\_1\_1, *m\_11\_2;
\textcolor{keyword}{public}:
  \textcolor{keywordtype}{void} setUp()
  \{
    m\_10\_1 = \textcolor{keyword}{new} Complex( 10, 1 );
    m\_1\_1 = \textcolor{keyword}{new} Complex( 1, 1 );
    m\_11\_2 = \textcolor{keyword}{new} Complex( 11, 2 );  
  \}

  \textcolor{keywordtype}{void} tearDown() 
  \{
    \textcolor{keyword}{delete} m\_10\_1;
    \textcolor{keyword}{delete} m\_1\_1;
    \textcolor{keyword}{delete} m\_11\_2;
  \}

  \textcolor{keywordtype}{void} testEquality()
  \{
    CPPUNIT\_ASSERT( *m\_10\_1 == *m\_10\_1 );
    CPPUNIT\_ASSERT( !(*m\_10\_1 == *m\_11\_2) );
  \}

  \textcolor{keywordtype}{void} testAddition()
  \{
    CPPUNIT\_ASSERT( *m\_10\_1 + *m\_1\_1 == *m\_11\_2 );
  \}
\};
\end{DoxyCode}


The name of the \hyperlink{}{Test\+Caller } added to the suite are a composition of the fixture name and the method name.

In the present case, the names would be\+: \char`\"{}\+Complex\+Number\+Test.\+test\+Equality\char`\"{} and \char`\"{}\+Complex\+Number\+Test.\+test\+Addition\char`\"{}.

The \hyperlink{group___writing_test_fixture}{helper macros } help you write comon assertion. For example, to check that Complex\+Number throws a Math\+Exception when dividing a number by 0\+:
\begin{DoxyItemize}
\item add the test to the suite using C\+P\+P\+U\+N\+I\+T\+\_\+\+T\+E\+S\+T\+\_\+\+E\+X\+C\+E\+P\+T\+I\+O\+N, specifying the expected exception type.
\item write the test case method
\end{DoxyItemize}


\begin{DoxyCode}
\hyperlink{group___writing_test_fixture_gabe1e12200f40d6f25d60c1783c99da81}{CPPUNIT\_TEST\_SUITE}( ComplexNumberTest );
\textcolor{comment}{// [...]}
\hyperlink{group___writing_test_fixture_gaca8eeb6f60714baade6cbfd185868c40}{CPPUNIT\_TEST\_EXCEPTION}( testDivideByZeroThrows, MathException );
\hyperlink{group___writing_test_fixture_ga601b2e1d525f3947b216e28c625abcb1}{CPPUNIT\_TEST\_SUITE\_END}();

\textcolor{comment}{// [...]}

  \textcolor{keywordtype}{void} testDivideByZeroThrows()
  \{
    \textcolor{comment}{// The following line should throw a MathException.}
    *m\_10\_1 / ComplexNumber(0);
  \}
\end{DoxyCode}


If the expected exception is not thrown, then a assertion failure is reported.\hypertarget{cppunit_cookbook_test_factory_registry}{}\section{Test\+Factory\+Registry}\label{cppunit_cookbook_test_factory_registry}
The \hyperlink{class_test_factory_registry}{Test\+Factory\+Registry} was created to solve two pitfalls\+:
\begin{DoxyItemize}
\item forgetting to add your fixture suite to the test runner (since it is in another file, it is easy to forget)
\item compilation bottleneck caused by the inclusion of all test case headers (see \hyperlink{cppunit_cookbook_test_runner_code}{previous example})
\end{DoxyItemize}

The \hyperlink{class_test_factory_registry}{Test\+Factory\+Registry} is a place where suites can be registered at initialization time.

To register the Complex\+Number suite, in the .cpp file, you add\+:


\begin{DoxyCode}
\textcolor{preprocessor}{#include <cppunit/extensions/HelperMacros.h>}

\hyperlink{group___creating_test_suite_ga2f4071eec88d1e306665ada0f2dd80e4}{CPPUNIT\_TEST\_SUITE\_REGISTRATION}( ComplexNumberTest );
\end{DoxyCode}


Behind the scene, a static variable type of \hyperlink{}{Auto\+Register\+Suite } is declared. On construction, it will \hyperlink{}{register } a \hyperlink{}{Test\+Suite\+Factory } into the \hyperlink{}{Test\+Factory\+Registry }. The \hyperlink{}{Test\+Suite\+Factory } returns the \hyperlink{}{Test\+Suite } returned by Complex\+Number\+::suite().

To run the tests, using the text test runner, we don't need to include the fixture anymore\+:


\begin{DoxyCode}
\textcolor{preprocessor}{#include <cppunit/extensions/TestFactoryRegistry.h>}
\textcolor{preprocessor}{#include <cppunit/ui/text/TestRunner.h>}

\textcolor{keywordtype}{int} main( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
  CppUnit::TextUi::TestRunner runner;
\end{DoxyCode}
 First, we retreive the instance of the \hyperlink{}{Test\+Factory\+Registry }\+: 
\begin{DoxyCode}
CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
\end{DoxyCode}
 Then, we obtain and add a new \hyperlink{}{Test\+Suite } created by the \hyperlink{}{Test\+Factory\+Registry } that contains all the test suite registered using \hyperlink{group___creating_test_suite_ga2f4071eec88d1e306665ada0f2dd80e4}{C\+P\+P\+U\+N\+I\+T\+\_\+\+T\+E\+S\+T\+\_\+\+S\+U\+I\+T\+E\+\_\+\+R\+E\+G\+I\+S\+T\+R\+A\+T\+I\+O\+N()}. 
\begin{DoxyCode}
  runner.addTest( registry.makeTest() );
  runner.run();
  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
\hypertarget{cppunit_cookbook_post_build_check}{}\section{Post-\/build check}\label{cppunit_cookbook_post_build_check}
Well, now that we have our unit tests running, how about integrating unit testing to our build process ?

To do that, the application must returns a value different than 0 to indicate that there was an error.

\hyperlink{}{Test\+Runner\+::run() } returns a boolean indicating if the run was successful.

Updating our main programm, we obtains\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <cppunit/extensions/TestFactoryRegistry.h>}
\textcolor{preprocessor}{#include <cppunit/ui/text/TestRunner.h>}

\textcolor{keywordtype}{int} main( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
  CppUnit::TextUi::TestRunner runner;
  CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
  runner.addTest( registry.makeTest() );
  \textcolor{keywordtype}{bool} wasSuccessful = runner.run( \textcolor{stringliteral}{""}, \textcolor{keyword}{false} );
  \textcolor{keywordflow}{return} !wasSuccessful;
\}
\end{DoxyCode}


Now, you need to run your application after compilation.

\hyperlink{struct_with}{With} Visual C++, this is done in {\itshape Project Settings/\+Post-\/\+Build step}, by adding the following command\+: {\ttfamily \char`\"{}\$(\+Target\+Path)\char`\"{}}. It is expanded to the application executable path. Look up the project {\ttfamily examples/cppunittest/\+Cpp\+Unit\+Test\+Main.\+dsp} which use that technic.

Original version by Michael Feathers. Doxygen conversion and update by Baptiste Lepilleur. 