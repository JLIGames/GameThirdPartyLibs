\hypertarget{structbt_soft_colliders_1_1_collide_c_l___r_s}{\section{bt\+Soft\+Colliders\+:\+:Collide\+C\+L\+\_\+\+R\+S Struct Reference}
\label{structbt_soft_colliders_1_1_collide_c_l___r_s}\index{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S}}
}


Inheritance diagram for bt\+Soft\+Colliders\+:\+:Collide\+C\+L\+\_\+\+R\+S\+:


Collaboration diagram for bt\+Soft\+Colliders\+:\+:Collide\+C\+L\+\_\+\+R\+S\+:
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{structbt_soft_colliders_1_1_collide_c_l___r_s_a020b9712f8e0c9c2dd901c93a1f97120}{Process} (const \hyperlink{structbt_dbvt_node}{bt\+Dbvt\+Node} $\ast$leaf)
\item 
void \hyperlink{structbt_soft_colliders_1_1_collide_c_l___r_s_a34f463ddcfcda480e9843277d4bd732e}{Process\+Col\+Obj} (\hyperlink{classbt_soft_body}{bt\+Soft\+Body} $\ast$ps, const \hyperlink{structbt_collision_object_wrapper}{bt\+Collision\+Object\+Wrapper} $\ast$col\+Ob\+Wrap)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{structbt_soft_colliders_1_1_collide_c_l___r_s_a0662ec8322a255b1dbc22b8ae512cd9c}{\hyperlink{classbt_soft_body}{bt\+Soft\+Body} $\ast$ {\bfseries psb}}\label{structbt_soft_colliders_1_1_collide_c_l___r_s_a0662ec8322a255b1dbc22b8ae512cd9c}

\item 
\hypertarget{structbt_soft_colliders_1_1_collide_c_l___r_s_a8e9189fbd214b4f700536892d098d0f4}{const \hyperlink{structbt_collision_object_wrapper}{bt\+Collision\+Object\+Wrapper} $\ast$ {\bfseries m\+\_\+col\+Obj\+Wrap}}\label{structbt_soft_colliders_1_1_collide_c_l___r_s_a8e9189fbd214b4f700536892d098d0f4}

\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\hypertarget{structbt_soft_colliders_1_1_collide_c_l___r_s_a020b9712f8e0c9c2dd901c93a1f97120}{\index{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S}!Process@{Process}}
\index{Process@{Process}!bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S}}
\subsubsection[{Process}]{\setlength{\rightskip}{0pt plus 5cm}void bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S\+::\+Process (
\begin{DoxyParamCaption}
\item[{const {\bf bt\+Dbvt\+Node} $\ast$}]{leaf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{structbt_soft_colliders_1_1_collide_c_l___r_s_a020b9712f8e0c9c2dd901c93a1f97120}
don't collide an anchored cluster with a static/kinematic object \hypertarget{structbt_soft_colliders_1_1_collide_c_l___r_s_a34f463ddcfcda480e9843277d4bd732e}{\index{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S}!Process\+Col\+Obj@{Process\+Col\+Obj}}
\index{Process\+Col\+Obj@{Process\+Col\+Obj}!bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S@{bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S}}
\subsubsection[{Process\+Col\+Obj}]{\setlength{\rightskip}{0pt plus 5cm}void bt\+Soft\+Colliders\+::\+Collide\+C\+L\+\_\+\+R\+S\+::\+Process\+Col\+Obj (
\begin{DoxyParamCaption}
\item[{{\bf bt\+Soft\+Body} $\ast$}]{ps, }
\item[{const {\bf bt\+Collision\+Object\+Wrapper} $\ast$}]{col\+Ob\+Wrap}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{structbt_soft_colliders_1_1_collide_c_l___r_s_a34f463ddcfcda480e9843277d4bd732e}
Bullet rigid body uses multiply instead of minimum to determine combined friction. Some customization would be useful. 

Here is the call graph for this function\+:




The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
bullet/bullet-\/2.\+82-\/r2704/src/\+Bullet\+Soft\+Body/bt\+Soft\+Body\+Internals.\+h\end{DoxyCompactItemize}
