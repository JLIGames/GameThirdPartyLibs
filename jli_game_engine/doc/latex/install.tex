\hypertarget{install_install_prebuilt}{}\section{Using the pre-\/built libraries with Visual C++ 8/9}\label{install_install_prebuilt}
If you develop at Visual Studio 2005 or 2008, you can simply use the pre-\/built linker libraries provided in the distribution. Extract all files to a place of your choice. A directory called \char`\"{}assimp\char`\"{} will be created there. Add the assimp/include path to your include paths (Menu-\/$>$Extras-\/$>$Options-\/$>$Projects and Solutions-\/$>$V\+C++ Directories-\/$>$Include files) and the assimp/lib/$<$Compiler$>$ path to your linker paths (Menu-\/$>$Extras-\/$>$Options-\/$>$Projects and Solutions-\/$>$V\+C++ Directories-\/$>$Library files). This is neccessary only once to setup all paths inside you I\+D\+E.

To use the library in your C++ project you have to include either $<$\hyperlink{_importer_8hpp_source}{assimp/\+Importer.\+hpp}$>$ or $<$\hyperlink{cimport_8h_source}{assimp/cimport.\+h}$>$ plus some others starting with $<$types.\+h$>$. If you set up your I\+D\+E correctly the compiler should be able to find the files. Then you have to add the linker library to your project dependencies. Link to $<$assimp\+\_\+root$>$/lib/$<$config-\/name$>$/assimp.lib. config-\/name is one of the predefined project configs. For static linking, use release/debug. See the sections below on this page for more information on the other build configs. If done correctly you should now be able to compile, link, run and use the application. If the linker complains about some integral functions being defined twice you propably have mixed the runtimes. Recheck the project configuration (project properties -\/$>$ C++ -\/$>$ Code generation -\/$>$ Runtime) if you use static runtimes (Multithreaded / Multithreaded Debug) or dynamic runtimes (Multithreaded D\+L\+L / Multithreaded Debug D\+L\+L). Choose the assimp linker lib accordingly. ~\newline
~\newline
 Please don't forget to also read the \hyperlink{install_assimp_stl}{Microsoft Compilers and the C++ Standard Library} section on M\+S\+V\+C and the S\+T\+L.\hypertarget{install_assimp_stl}{}\section{Microsoft Compilers and the C++ Standard Library}\label{install_assimp_stl}
In V\+C8 and V\+C9 Microsoft introduced some Standard Library debugging features. A good example are improved iterator checks and various useful debug checks. The problem is the performance penalty that incurs with those extra checks.

Most of these security enhancements are active in release builds by default, rendering assimp several times slower. However, it is possible to disable them by setting


\begin{DoxyCode}
\_HAS\_ITERATOR\_DEBUGGING=0
\_SECURE\_SCL=0
\end{DoxyCode}


in the preprocessor options (or alternatively in the source code, just before the S\+T\+L is included for the first time). {\bfseries assimp's vc8 and vc9 configs enable these flags by default}.

{\itshape If you're linking statically against assimp\+:} Make sure your applications uses the same S\+Tl settings! If you do not, there are two binary incompatible S\+T\+L versions mangled together and you'll crash. Alternatively you can disable the fast S\+T\+L settings for assimp by removing the 'Fast\+S\+T\+L' property sheet from the vc project file.

{\itshape If you're using assimp in a D\+L\+L/\+S\+O\+:} It's ok. There's no S\+T\+L used in the binary D\+L\+L/\+S\+O interface, so it doesn't care whether your application uses the same S\+T\+L settings or not. ~\newline
~\newline
 Another option is to build against a different S\+T\+L implementation, for example S\+Tlport. There's a special \hyperlink{install_assimp_stlport}{Building against S\+T\+Lport} section that has a description how to achieve this.\hypertarget{install_install_own}{}\section{Building the library from scratch}\label{install_install_own}
To build the library on your own you first have to get hold of the dependencies. Fortunately, special attention was paid to keep the list of dependencies short. Unfortunately, the only dependency is \href{http://www.boost.org}{\tt boost} which can be a bit painful to set up for certain development environments. Boost is a widely used collection of classes and functions for various purposes. Chances are that it was already installed along with your compiler. If not, you have to install it for yourself. Read the \char`\"{}\+Getting Started\char`\"{} section of the Boost documentation for how to setup boost. Visual\+Studio users can use a comfortable installer from \href{http://www.boost-consulting.com/products/free}{\tt http\+://www.\+boost-\/consulting.\+com/products/free}. Choose the appropriate version of boost for your runtime of choice.

{\bfseries If you don't want to use boost}, you can build against our {\itshape \char`\"{}\+Boost-\/\+Workaround\char`\"{}}. It consists of very small implementations of the various boost utility classes used. However, you'll lose functionality (e.\+g. threading) by doing this. So, if you can use boost, you should use boost. Otherwise, See the \hyperlink{install_use_noboost}{No\+Boost-\/\+Section } later on this page for the details of the workaround.

Once boost is working, you have to set up a project for the assimp library in your favorite I\+D\+E. If you use V\+C2005 or V\+C2008, you can simply load the solution or project files in the workspaces/ folder, otherwise you have to create a new package and add all the headers and source files from the include/ and code/ directories. Set the temporary output folder to obj/, for example, and redirect the output folder to bin/. Then build the library -\/ it should compile and link fine.

The last step is to integrate the library into your project. This is basically the same task as described in the \char`\"{}\+Using the pre-\/built libraries\char`\"{} section above\+: add the include/ and bin/ directories to your I\+D\+E's paths so that the compiler can find the library files. Alternatively you can simply add the assimp project to your project's overall solution and build it inside your solution.\hypertarget{install_use_noboost}{}\section{Building without boost.}\label{install_use_noboost}
The Boost-\/\+Workaround consists of dummy replacements for some boost utility templates. Currently there are replacements for


\begin{DoxyItemize}
\item \hyperlink{classboost_1_1scoped__ptr}{boost.\+scoped\+\_\+ptr}
\item \hyperlink{classboost_1_1scoped__array}{boost.\+scoped\+\_\+array}
\item \hyperlink{classboost_1_1format}{boost.\+format}
\item boost.\+random
\item boost.\+common\+\_\+factor
\item boost.\+foreach
\item \hyperlink{classboost_1_1tuple}{boost.\+tuple}
\item boost.\+make\+\_\+shared
\end{DoxyItemize}

These implementations are very limited and are not intended for use outside assimp. A compiler with full support for partial template specializations is required. To enable the workaround, put the following in your compiler's list of predefined macros\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#define ASSIMP\_BUILD\_BOOST\_WORKAROUND}
\end{DoxyCode}
 ~\newline
 If you're working with the provided solutions for Visual Studio use the {\itshape -\/noboost} build configs. ~\newline


{\bfseries assimp\+\_\+\+B\+U\+I\+L\+D\+\_\+\+B\+O\+O\+S\+T\+\_\+\+W\+O\+R\+K\+A\+R\+O\+U\+N\+D} implies {\bfseries assimp\+\_\+\+B\+U\+I\+L\+D\+\_\+\+S\+I\+N\+G\+L\+E\+T\+H\+R\+E\+A\+D\+E\+D}. ~\newline
 See the assimp\+\_\+st section for more details.\hypertarget{install_assimp_dll}{}\section{Windows D\+L\+L Build}\label{install_assimp_dll}
assimp can be built as D\+L\+L. You just need to select a -\/dll config from the list of project configs and you're fine.

{\bfseries N\+O\+T\+E\+:} Theoretically, assimp-\/dll can be used with multithreaded (non-\/dll) runtime libraries, as long as you don't utilize any non-\/public stuff from the code folder. However, if you happen to encounter {\itshape very} strange problems, try changing the runtime to {\itshape Multithreaded (Debug) D\+L\+L}.\hypertarget{install_assimp_stlport}{}\section{Building against S\+T\+Lport}\label{install_assimp_stlport}
S\+T\+Lport is a free, fast and secure S\+T\+L replacement that works with all major compilers and platforms. To get it, download the latest release from \href{http://www.stlport.org}{\tt $<$stlport.\+org$>$}. Usually you'll just need to run 'configure' + a makefile (see their R\+E\+A\+D\+M\+E for more details). Don't miss to add $<$stlport\+\_\+root$>$/stlport to your compiler's default include paths -\/ {\bfseries prior} to the directory where your compiler vendor's headers lie. Do the same for $<$stlport\+\_\+root$>$/lib and recompile assimp. To ensure you're really building against S\+T\+Lport see ai\+Get\+Compile\+Flags(). ~\newline
 In our testing, S\+T\+Lport builds tend to be a bit faster than builds against Microsoft's C++ Standard Library. 