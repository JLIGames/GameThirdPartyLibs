\hypertarget{class_mesh_interface}{\section{Mesh\+Interface Class Reference}
\label{class_mesh_interface}\index{Mesh\+Interface@{Mesh\+Interface}}
}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_mesh_interface_aba590ec6ec5432322174b1450745f808}{Mesh\+Interface} ()
\item 
\hyperlink{class_mesh_interface_abb1a0da3ced5e305f059d66b289a1f85}{$\sim$\+Mesh\+Interface} ()
\item 
\hypertarget{class_mesh_interface_a166fa0dd2932406c1662f11308d143f0}{inline\+\_\+ \hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword} {\bfseries Get\+Nb\+Triangles} () const }\label{class_mesh_interface_a166fa0dd2932406c1662f11308d143f0}

\item 
\hypertarget{class_mesh_interface_a9f4e57faca3d41acb1e595f221b71769}{inline\+\_\+ \hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword} {\bfseries Get\+Nb\+Vertices} () const }\label{class_mesh_interface_a9f4e57faca3d41acb1e595f221b71769}

\item 
\hypertarget{class_mesh_interface_abfd3284e03432fe0fefe895b79df6cdf}{inline\+\_\+ void {\bfseries Set\+Nb\+Triangles} (\hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword} nb)}\label{class_mesh_interface_abfd3284e03432fe0fefe895b79df6cdf}

\item 
\hypertarget{class_mesh_interface_a5f9a5aae4efcd8d21a174fedbdcbfcf7}{inline\+\_\+ void {\bfseries Set\+Nb\+Vertices} (\hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword} nb)}\label{class_mesh_interface_a5f9a5aae4efcd8d21a174fedbdcbfcf7}

\item 
bool \hyperlink{class_mesh_interface_a4810ebe4cad5b7ff08ca26187fa1c301}{Set\+Pointers} (const \hyperlink{class_indexed_triangle}{Indexed\+Triangle} $\ast$tris, const \hyperlink{class_point}{Point} $\ast$verts)
\item 
\hypertarget{class_mesh_interface_a5c3594184da578eee7b7163453bf0269}{inline\+\_\+ const \hyperlink{class_indexed_triangle}{Indexed\+Triangle} $\ast$ {\bfseries Get\+Tris} () const }\label{class_mesh_interface_a5c3594184da578eee7b7163453bf0269}

\item 
\hypertarget{class_mesh_interface_ac2ba230f02dbec05b265c31b1f76bed3}{inline\+\_\+ const \hyperlink{class_point}{Point} $\ast$ {\bfseries Get\+Verts} () const }\label{class_mesh_interface_ac2ba230f02dbec05b265c31b1f76bed3}

\item 
inline\+\_\+ void \hyperlink{class_mesh_interface_ae2ce7bb92b4a2825147c33616114f2c1}{Get\+Triangle} (\hyperlink{struct_vertex_pointers}{Vertex\+Pointers} \&vp, \hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword} index) const 
\item 
inline\+\_\+ bool \hyperlink{class_mesh_interface_a7507e521cb4cd844960dd5e24eba937a}{Remap\+Client} (\hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword} nb\+\_\+indices, const \hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword} $\ast$permutation) const 
\item 
bool \hyperlink{class_mesh_interface_a28e02f1fa9f6d41523fae3f8649fcdb5}{Is\+Valid} () const 
\item 
\hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword} \hyperlink{class_mesh_interface_a27f3838ddf40b99457039bf161fc2aa7}{Check\+Topology} () const 
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class is an interface between us and user-\/defined meshes. Meshes can be defined in a lot of ways, and here we try to support most of them.

Basically you have two options\+:
\begin{DoxyItemize}
\item callbacks, if O\+P\+C\+\_\+\+U\+S\+E\+\_\+\+C\+A\+L\+L\+B\+A\+C\+K\+S is defined in \hyperlink{_o_p_c___settings_8h}{O\+P\+C\+\_\+\+Settings.\+h}.
\item else pointers.
\end{DoxyItemize}

If using pointers, you can also use strides or not. Strides are used when O\+P\+C\+\_\+\+U\+S\+E\+\_\+\+S\+T\+R\+I\+D\+E is defined.

C\+A\+L\+L\+B\+A\+C\+K\+S\+:

Using callbacks is the most generic way to feed O\+P\+C\+O\+D\+E with your meshes. Indeed, you just have to give access to three vertices at the end of the day. It's up to you to fetch them from your database, using whatever method you want. Hence your meshes can lie in system memory or A\+G\+P, be indexed or not, use 16 or 32-\/bits indices, you can decompress them on-\/the-\/fly if needed, etc. On the other hand, a callback is called each time O\+P\+C\+O\+D\+E needs access to a particular triangle, so there might be a slight overhead.

To make things clear\+: geometry \& topology are N\+O\+T stored in the collision system, in order to save some ram. So, when the system needs them to perform accurate intersection tests, you're requested to provide the triangle-\/vertices corresponding to a given face index.

Ex\+:


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keywordtype}{void} ColCallback(udword triangle\_index, \hyperlink{struct_vertex_pointers}{VertexPointers}& triangle, udword user\_data)
\{
    \textcolor{comment}{// Get back Mesh0 or Mesh1 (you also can use 2 different callbacks)}
    \hyperlink{class_mesh}{Mesh}* MyMesh = (\hyperlink{class_mesh}{Mesh}*)user\_data;
    \textcolor{comment}{// Get correct triangle in the app-controlled database}
    \textcolor{keyword}{const} \hyperlink{class_triangle}{Triangle}* Tri = MyMesh->GetTriangle(triangle\_index);
    \textcolor{comment}{// Setup pointers to vertices for the collision system}
    triangle.Vertex[0] = MyMesh->GetVertex(Tri->mVRef[0]);
    triangle.Vertex[1] = MyMesh->GetVertex(Tri->mVRef[1]);
    triangle.Vertex[2] = MyMesh->GetVertex(Tri->mVRef[2]);
\}

\textcolor{comment}{// Setup callbacks}
MeshInterface0->SetCallback(ColCallback, \hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword}(Mesh0));
MeshInterface1->SetCallback(ColCallback, \hyperlink{_ice_types_8h_a44c6f1920ba5551225fb534f9d1a1733}{udword}(Mesh1));
\end{DoxyCode}


Of course, you should make this callback as fast as possible. And you're also not supposed to modify the geometry {\itshape after} the collision trees have been built. The alternative was to store the geometry \& topology in the collision system as well (as in R\+A\+P\+I\+D) but we have found this approach to waste a lot of ram in many cases.

P\+O\+I\+N\+T\+E\+R\+S\+:

If you're internally using the following canonical structures\+:
\begin{DoxyItemize}
\item a vertex made of three 32-\/bits floating point values
\item a triangle made of three 32-\/bits integer vertex references ...then you may want to use pointers instead of callbacks. This is the same, except O\+P\+C\+O\+D\+E will directly use provided pointers to access the topology and geometry, without using a callback. It might be faster, but probably not as safe. Pointers have been introduced in O\+P\+C\+O\+D\+E 1.\+2.
\end{DoxyItemize}

Ex\+:


\begin{DoxyCode}
\textcolor{comment}{// Setup pointers}
MeshInterface0->SetPointers(Mesh0->GetFaces(), Mesh0->GetVerts());
MeshInterface1->SetPointers(Mesh1->GetFaces(), Mesh1->GetVerts());
\end{DoxyCode}


S\+T\+R\+I\+D\+E\+S\+:

If your vertices are D3\+D-\/like entities interleaving a position, a normal and/or texture coordinates (i.\+e. if your vertices are F\+V\+Fs), you might want to use a vertex stride to skip extra data O\+P\+C\+O\+D\+E doesn't need. Using a stride shouldn't be notably slower than not using it, but it might increase cache misses. Please also note that you {\itshape shouldn't} read from A\+G\+P or video-\/memory buffers !

In any case, compilation flags are here to select callbacks/pointers/strides at compile time, so choose what's best for your application. All of this has been wrapped into this \hyperlink{class_mesh_interface}{Mesh\+Interface}.

\begin{DoxyAuthor}{Author}
Pierre Terdiman 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+3 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
November, 27, 2002 
\end{DoxyDate}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_mesh_interface_aba590ec6ec5432322174b1450745f808}{\index{Mesh\+Interface@{Mesh\+Interface}!Mesh\+Interface@{Mesh\+Interface}}
\index{Mesh\+Interface@{Mesh\+Interface}!Mesh\+Interface@{Mesh\+Interface}}
\subsubsection[{Mesh\+Interface}]{\setlength{\rightskip}{0pt plus 5cm}Mesh\+Interface\+::\+Mesh\+Interface (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{class_mesh_interface_aba590ec6ec5432322174b1450745f808}
Constructor. \hypertarget{class_mesh_interface_abb1a0da3ced5e305f059d66b289a1f85}{\index{Mesh\+Interface@{Mesh\+Interface}!````~Mesh\+Interface@{$\sim$\+Mesh\+Interface}}
\index{````~Mesh\+Interface@{$\sim$\+Mesh\+Interface}!Mesh\+Interface@{Mesh\+Interface}}
\subsubsection[{$\sim$\+Mesh\+Interface}]{\setlength{\rightskip}{0pt plus 5cm}Mesh\+Interface\+::$\sim$\+Mesh\+Interface (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{class_mesh_interface_abb1a0da3ced5e305f059d66b289a1f85}
Destructor. 

\subsection{Member Function Documentation}
\hypertarget{class_mesh_interface_a27f3838ddf40b99457039bf161fc2aa7}{\index{Mesh\+Interface@{Mesh\+Interface}!Check\+Topology@{Check\+Topology}}
\index{Check\+Topology@{Check\+Topology}!Mesh\+Interface@{Mesh\+Interface}}
\subsubsection[{Check\+Topology}]{\setlength{\rightskip}{0pt plus 5cm}{\bf udword} Mesh\+Interface\+::\+Check\+Topology (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{class_mesh_interface_a27f3838ddf40b99457039bf161fc2aa7}
Checks the mesh itself is valid. Currently we only look for degenerate faces. \begin{DoxyReturn}{Returns}
number of degenerate faces 
\end{DoxyReturn}
\hypertarget{class_mesh_interface_ae2ce7bb92b4a2825147c33616114f2c1}{\index{Mesh\+Interface@{Mesh\+Interface}!Get\+Triangle@{Get\+Triangle}}
\index{Get\+Triangle@{Get\+Triangle}!Mesh\+Interface@{Mesh\+Interface}}
\subsubsection[{Get\+Triangle}]{\setlength{\rightskip}{0pt plus 5cm}inline\+\_\+ void Mesh\+Interface\+::\+Get\+Triangle (
\begin{DoxyParamCaption}
\item[{{\bf Vertex\+Pointers} \&}]{vp, }
\item[{{\bf udword}}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{class_mesh_interface_ae2ce7bb92b4a2825147c33616114f2c1}
Fetches a triangle given a triangle index. 
\begin{DoxyParams}{Parameters}
{\em vp} & \mbox{[}out\mbox{]} required triangle's vertex pointers \\
\hline
{\em index} & \mbox{[}in\mbox{]} triangle index \\
\hline
\end{DoxyParams}
\hypertarget{class_mesh_interface_a28e02f1fa9f6d41523fae3f8649fcdb5}{\index{Mesh\+Interface@{Mesh\+Interface}!Is\+Valid@{Is\+Valid}}
\index{Is\+Valid@{Is\+Valid}!Mesh\+Interface@{Mesh\+Interface}}
\subsubsection[{Is\+Valid}]{\setlength{\rightskip}{0pt plus 5cm}bool Mesh\+Interface\+::\+Is\+Valid (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{class_mesh_interface_a28e02f1fa9f6d41523fae3f8649fcdb5}
Checks the mesh interface is valid, i.\+e. things have been setup correctly. \begin{DoxyReturn}{Returns}
true if valid 
\end{DoxyReturn}
\hypertarget{class_mesh_interface_a7507e521cb4cd844960dd5e24eba937a}{\index{Mesh\+Interface@{Mesh\+Interface}!Remap\+Client@{Remap\+Client}}
\index{Remap\+Client@{Remap\+Client}!Mesh\+Interface@{Mesh\+Interface}}
\subsubsection[{Remap\+Client}]{\setlength{\rightskip}{0pt plus 5cm}bool Mesh\+Interface\+::\+Remap\+Client (
\begin{DoxyParamCaption}
\item[{{\bf udword}}]{nb\+\_\+indices, }
\item[{const {\bf udword} $\ast$}]{permutation}
\end{DoxyParamCaption}
) const}}\label{class_mesh_interface_a7507e521cb4cd844960dd5e24eba937a}
Remaps client's mesh according to a permutation. 
\begin{DoxyParams}{Parameters}
{\em nb\+\_\+indices} & \mbox{[}in\mbox{]} number of indices in the permutation (will be checked against number of triangles) \\
\hline
{\em permutation} & \mbox{[}in\mbox{]} list of triangle indices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if success 
\end{DoxyReturn}
\hypertarget{class_mesh_interface_a4810ebe4cad5b7ff08ca26187fa1c301}{\index{Mesh\+Interface@{Mesh\+Interface}!Set\+Pointers@{Set\+Pointers}}
\index{Set\+Pointers@{Set\+Pointers}!Mesh\+Interface@{Mesh\+Interface}}
\subsubsection[{Set\+Pointers}]{\setlength{\rightskip}{0pt plus 5cm}bool Mesh\+Interface\+::\+Set\+Pointers (
\begin{DoxyParamCaption}
\item[{const {\bf Indexed\+Triangle} $\ast$}]{tris, }
\item[{const {\bf Point} $\ast$}]{verts}
\end{DoxyParamCaption}
)}}\label{class_mesh_interface_a4810ebe4cad5b7ff08ca26187fa1c301}
Pointers control\+: setups object pointers. Must provide access to faces and vertices for a given object. 
\begin{DoxyParams}{Parameters}
{\em tris} & \mbox{[}in\mbox{]} pointer to triangles \\
\hline
{\em verts} & \mbox{[}in\mbox{]} pointer to vertices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if success 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
bullet/bullet-\/2.\+82-\/r2704/\+Extras/\+C\+D\+Test\+Framework/\+Opcode/\hyperlink{_o_p_c___mesh_interface_8h}{O\+P\+C\+\_\+\+Mesh\+Interface.\+h}\item 
bullet/bullet-\/2.\+82-\/r2704/\+Extras/\+C\+D\+Test\+Framework/\+Opcode/\hyperlink{_o_p_c___mesh_interface_8cpp}{O\+P\+C\+\_\+\+Mesh\+Interface.\+cpp}\end{DoxyCompactItemize}
