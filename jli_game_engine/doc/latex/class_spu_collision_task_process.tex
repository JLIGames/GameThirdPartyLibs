\hypertarget{class_spu_collision_task_process}{\section{Spu\+Collision\+Task\+Process Class Reference}
\label{class_spu_collision_task_process}\index{Spu\+Collision\+Task\+Process@{Spu\+Collision\+Task\+Process}}
}


{\ttfamily \#include $<$Spu\+Collision\+Task\+Process.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_spu_collision_task_process_ae2fd53d16de149643d8f538e183e48eb}{{\bfseries Spu\+Collision\+Task\+Process} (\hyperlink{classbt_thread_support_interface}{bt\+Thread\+Support\+Interface} $\ast$thread\+Interface, unsigned int max\+Num\+Outstanding\+Tasks)}\label{class_spu_collision_task_process_ae2fd53d16de149643d8f538e183e48eb}

\item 
\hypertarget{class_spu_collision_task_process_afcdb413769d35c957ddc5c8ec2985588}{void \hyperlink{class_spu_collision_task_process_afcdb413769d35c957ddc5c8ec2985588}{initialize2} (bool use\+Epa=false)}\label{class_spu_collision_task_process_afcdb413769d35c957ddc5c8ec2985588}

\begin{DoxyCompactList}\small\item\em call initialize in the beginning of the frame, before add\+Collision\+Pair\+To\+Task \end{DoxyCompactList}\item 
\hypertarget{class_spu_collision_task_process_a5a0c4e28e49f0ecfd3aa8255960c77d2}{void \hyperlink{class_spu_collision_task_process_a5a0c4e28e49f0ecfd3aa8255960c77d2}{add\+Work\+To\+Task} (void $\ast$pair\+Array\+Ptr, int start\+Index, int end\+Index)}\label{class_spu_collision_task_process_a5a0c4e28e49f0ecfd3aa8255960c77d2}

\begin{DoxyCompactList}\small\item\em batch up additional work to a current task for S\+P\+U processing. When batch is full, it issues the task. \end{DoxyCompactList}\item 
\hypertarget{class_spu_collision_task_process_afdb2b028ac84b0e90286eb6d4ed10fd3}{void \hyperlink{class_spu_collision_task_process_afdb2b028ac84b0e90286eb6d4ed10fd3}{flush2} ()}\label{class_spu_collision_task_process_afdb2b028ac84b0e90286eb6d4ed10fd3}

\begin{DoxyCompactList}\small\item\em call flush to submit potential outstanding work to S\+P\+Us and wait for all involved S\+P\+Us to be finished \end{DoxyCompactList}\item 
void \hyperlink{class_spu_collision_task_process_aa079f41eb800756bff561982db6dab00}{set\+Num\+Tasks} (int max\+Num\+Tasks)
\begin{DoxyCompactList}\small\item\em set the maximum number of S\+P\+U tasks allocated \end{DoxyCompactList}\item 
\hypertarget{class_spu_collision_task_process_a20f6369df9bc1befa8185f84ede9c3f3}{int {\bfseries get\+Num\+Tasks} () const }\label{class_spu_collision_task_process_a20f6369df9bc1befa8185f84ede9c3f3}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{class_spu_collision_task_process}{Spu\+Collision\+Task\+Process} handles S\+P\+U processing of collision pairs. Maintains a set of task buffers. When the task is full, the task is issued for S\+P\+Us to process. Contact output goes into bt\+Persistent\+Manifold associated with each task. When P\+P\+U issues a task, it will look for completed task buffers P\+P\+U will do postprocessing, dependent on workunit output (not likely) 

\subsection{Member Function Documentation}
\hypertarget{class_spu_collision_task_process_aa079f41eb800756bff561982db6dab00}{\index{Spu\+Collision\+Task\+Process@{Spu\+Collision\+Task\+Process}!set\+Num\+Tasks@{set\+Num\+Tasks}}
\index{set\+Num\+Tasks@{set\+Num\+Tasks}!Spu\+Collision\+Task\+Process@{Spu\+Collision\+Task\+Process}}
\subsubsection[{set\+Num\+Tasks}]{\setlength{\rightskip}{0pt plus 5cm}void Spu\+Collision\+Task\+Process\+::set\+Num\+Tasks (
\begin{DoxyParamCaption}
\item[{int}]{max\+Num\+Tasks}
\end{DoxyParamCaption}
)}}\label{class_spu_collision_task_process_aa079f41eb800756bff561982db6dab00}


set the maximum number of S\+P\+U tasks allocated 

re-\/allocate task memory buffers 

Here is the call graph for this function\+:




Here is the caller graph for this function\+:




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
bullet/bullet-\/2.\+82-\/r2704/src/\+Bullet\+Multi\+Threaded/Spu\+Collision\+Task\+Process.\+h\item 
bullet/bullet-\/2.\+82-\/r2704/src/\+Bullet\+Multi\+Threaded/Spu\+Collision\+Task\+Process.\+cpp\end{DoxyCompactItemize}
