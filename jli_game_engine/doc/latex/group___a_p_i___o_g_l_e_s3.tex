\hypertarget{group___a_p_i___o_g_l_e_s3}{\section{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3}
\label{group___a_p_i___o_g_l_e_s3}\index{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3@{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3}}
}


Tools for the Open\+G\+L E\+S 3.\+0 A\+P\+I.  


Collaboration diagram for A\+P\+I\+\_\+\+O\+G\+L\+E\+S3\+:
\subsection*{Files}
\begin{DoxyCompactItemize}
\item 
file \hyperlink{_o_g_l_e_s31_tools_8h}{O\+G\+L\+E\+S31\+Tools.\+h}
\begin{DoxyCompactList}\small\item\em Header file of O\+G\+L\+E\+S3\+Tools.\+lib. \end{DoxyCompactList}\item 
file \hyperlink{_o_g_l_e_s3_tools_8h}{O\+G\+L\+E\+S3\+Tools.\+h}
\begin{DoxyCompactList}\small\item\em Header file of O\+G\+L\+E\+S3\+Tools.\+lib. \end{DoxyCompactList}\item 
file \hyperlink{_p_v_r_tgles3_ext_8h}{P\+V\+R\+Tgles3\+Ext.\+h}
\begin{DoxyCompactList}\small\item\em Open\+G\+L E\+S 3.\+0 extensions. \end{DoxyCompactList}\item 
file \hyperlink{_2_p_v_r_t_texture_a_p_i_8h}{P\+V\+R\+T\+Texture\+A\+P\+I.\+h}
\begin{DoxyCompactList}\small\item\em O\+G\+L\+E\+S3 texture loading. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class_c_p_v_r_tgles3_ext}{C\+P\+V\+R\+Tgles3\+Ext}
\begin{DoxyCompactList}\small\item\em A class for initialising and managing O\+G\+L\+E\+S3 extensions. \end{DoxyCompactList}\item 
class \hyperlink{singleton_c_p_v_r_t_map}{C\+P\+V\+R\+T\+Map$<$ Key\+Type, Data\+Type $>$}
\begin{DoxyCompactList}\small\item\em Expanding map template class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\hypertarget{group___a_p_i___o_g_l_e_s3_ga4d75a8396541a8b002cc3b1b4f292604}{\#define {\bfseries P\+V\+R\+Get\+Proc\+Address}(x)~egl\+Get\+Proc\+Address(\#x)}\label{group___a_p_i___o_g_l_e_s3_ga4d75a8396541a8b002cc3b1b4f292604}

\item 
\hypertarget{group___a_p_i___o_g_l_e_s3_ga2eb4395839440f4db904a0cd3c6061f4}{\#define {\bfseries G\+L\+\_\+\+P\+V\+R\+T\+G\+L\+E\+S\+E\+X\+T\+\_\+\+V\+E\+R\+S\+I\+O\+N}~3}\label{group___a_p_i___o_g_l_e_s3_ga2eb4395839440f4db904a0cd3c6061f4}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{_p_v_r_t_error_8h_a9e837ff1a83f3a5f332bc4cc78454608}{E\+P\+V\+R\+T\+Error} \hyperlink{group___a_p_i___o_g_l_e_s3_ga49dc74480ad4ec5a2f393f641117d54f}{P\+V\+R\+T\+Texture\+Load\+From\+Pointer} (const void $\ast$pointer, G\+Luint $\ast$const tex\+Name, const void $\ast$ps\+Texture\+Header=N\+U\+L\+L, bool b\+Allow\+Decompress=true, const unsigned int n\+Load\+From\+Level=0, const void $\ast$const tex\+Ptr=0, \hyperlink{singleton_c_p_v_r_t_map}{C\+P\+V\+R\+T\+Map}$<$ unsigned int, \hyperlink{singleton_c_p_v_r_t_map}{C\+P\+V\+R\+T\+Map}$<$ unsigned int, struct \hyperlink{struct_meta_data_block}{Meta\+Data\+Block} $>$ $>$ $\ast$p\+Meta\+Data=N\+U\+L\+L)
\begin{DoxyCompactList}\small\item\em Allows textures to be stored in C header files and loaded in. Can load parts of a mipmaped texture (ie skipping the highest detailed levels). Sets the texture M\+I\+N/\+M\+A\+G filter to G\+L\+\_\+\+L\+I\+N\+E\+A\+R\+\_\+\+M\+I\+P\+M\+A\+P\+\_\+\+N\+E\+A\+R\+E\+S\+T/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R if mipmaps are present, G\+L\+\_\+\+L\+I\+N\+E\+A\+R/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R otherwise. \end{DoxyCompactList}\item 
\hyperlink{_p_v_r_t_error_8h_a9e837ff1a83f3a5f332bc4cc78454608}{E\+P\+V\+R\+T\+Error} \hyperlink{group___a_p_i___o_g_l_e_s3_ga6eecac4c871ba7ccdd0ef4b057a7d596}{P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R} (const char $\ast$const filename, G\+Luint $\ast$const tex\+Name, const void $\ast$ps\+Texture\+Header=N\+U\+L\+L, bool b\+Allow\+Decompress=true, const unsigned int n\+Load\+From\+Level=0, \hyperlink{singleton_c_p_v_r_t_map}{C\+P\+V\+R\+T\+Map}$<$ unsigned int, \hyperlink{singleton_c_p_v_r_t_map}{C\+P\+V\+R\+T\+Map}$<$ unsigned int, struct \hyperlink{struct_meta_data_block}{Meta\+Data\+Block} $>$ $>$ $\ast$p\+Meta\+Data=N\+U\+L\+L)
\begin{DoxyCompactList}\small\item\em Allows textures to be stored in binary P\+V\+R files and loaded in. Can load parts of a mipmaped texture (ie skipping the highest detailed levels). Sets the texture M\+I\+N/\+M\+A\+G filter to G\+L\+\_\+\+L\+I\+N\+E\+A\+R\+\_\+\+M\+I\+P\+M\+A\+P\+\_\+\+N\+E\+A\+R\+E\+S\+T/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R if mipmaps are present, G\+L\+\_\+\+L\+I\+N\+E\+A\+R/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R otherwise. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Tools for the Open\+G\+L E\+S 3.\+0 A\+P\+I. 



\subsection{Function Documentation}
\hypertarget{group___a_p_i___o_g_l_e_s3_ga49dc74480ad4ec5a2f393f641117d54f}{\index{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3@{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3}!P\+V\+R\+T\+Texture\+Load\+From\+Pointer@{P\+V\+R\+T\+Texture\+Load\+From\+Pointer}}
\index{P\+V\+R\+T\+Texture\+Load\+From\+Pointer@{P\+V\+R\+T\+Texture\+Load\+From\+Pointer}!A\+P\+I\+\_\+\+O\+G\+L\+E\+S3@{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3}}
\subsubsection[{P\+V\+R\+T\+Texture\+Load\+From\+Pointer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf E\+P\+V\+R\+T\+Error} P\+V\+R\+T\+Texture\+Load\+From\+Pointer (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{pointer, }
\item[{G\+Luint $\ast$const}]{tex\+Name, }
\item[{const void $\ast$}]{ps\+Texture\+Header, }
\item[{bool}]{b\+Allow\+Decompress, }
\item[{const unsigned int}]{n\+Load\+From\+Level, }
\item[{const void $\ast$const}]{tex\+Ptr, }
\item[{{\bf C\+P\+V\+R\+T\+Map}$<$ unsigned int, {\bf C\+P\+V\+R\+T\+Map}$<$ unsigned int, {\bf Meta\+Data\+Block} $>$ $>$ $\ast$}]{p\+Meta\+Data}
\end{DoxyParamCaption}
)}}\label{group___a_p_i___o_g_l_e_s3_ga49dc74480ad4ec5a2f393f641117d54f}


Allows textures to be stored in C header files and loaded in. Can load parts of a mipmaped texture (ie skipping the highest detailed levels). Sets the texture M\+I\+N/\+M\+A\+G filter to G\+L\+\_\+\+L\+I\+N\+E\+A\+R\+\_\+\+M\+I\+P\+M\+A\+P\+\_\+\+N\+E\+A\+R\+E\+S\+T/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R if mipmaps are present, G\+L\+\_\+\+L\+I\+N\+E\+A\+R/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R otherwise. 



 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pointer} & Pointer to header-\/texture's structure \\
\hline
\mbox{\tt in,out}  & {\em tex\+Name} & the Open\+G\+L E\+S texture name as returned by gl\+Bind\+Texture \\
\hline
\mbox{\tt in,out}  & {\em ps\+Texture\+Header} & Pointer to a \hyperlink{struct_p_v_r_texture_header_v3}{P\+V\+R\+Texture\+Header\+V3} struct. Modified to contain the header data of the returned texture Ignored if N\+U\+L\+L. \\
\hline
\mbox{\tt in}  & {\em b\+Allow\+Decompress} & Allow decompression if P\+V\+R\+T\+C is not supported in hardware. \\
\hline
\mbox{\tt in}  & {\em n\+Load\+From\+Level} & Which mipmap level to start loading from (0=all) \\
\hline
\mbox{\tt in}  & {\em tex\+Ptr} & If null, texture follows header, else texture is here. \\
\hline
\mbox{\tt in,out}  & {\em p\+Meta\+Data} & If a valid map is supplied, this will return any and all Meta\+Data\+Blocks stored in the texture, organised by Dev\+Four\+C\+C then identifier. Supplying N\+U\+L\+L will ignore all Meta\+Data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
P\+V\+R\+\_\+\+S\+U\+C\+C\+E\+S\+S on success
\end{DoxyReturn}


  P\+V\+R\+T\+Texture\+Load\+From\+Pointer  pointer Pointer to header-\/texture's structure  tex\+Name the Open\+G\+L E\+S texture name as returned by gl\+Bind\+Texture  ps\+Texture\+Header Pointer to a \hyperlink{struct_p_v_r_texture_header_v3}{P\+V\+R\+Texture\+Header\+V3} struct. Modified to contain the header data of the returned texture Ignored if N\+U\+L\+L.  b\+Allow\+Decompress Allow decompression if P\+V\+R\+T\+C is not supported in hardware.  n\+Load\+From\+Level Which mip map level to start loading from (0=all)  tex\+Ptr If null, texture follows header, else texture is here.  p\+Meta\+Data If a valid map is supplied, this will return any and all Meta\+Data\+Blocks stored in the texture, organised by Dev\+Four\+C\+C then identifier. Supplying N\+U\+L\+L will ignore all Meta\+Data.  P\+V\+R\+\_\+\+S\+U\+C\+C\+E\+S\+S on success  Allows textures to be stored in C header files and loaded in. Can load parts of a mip mapped texture (i.\+e. skipping the highest detailed levels). In Open\+G\+L Cube Map, each texture's up direction is defined as next (view direction, up direction), (+x,-\/y)(-\/x,-\/y)(+y,+z)(-\/y,-\/z)(+z,-\/y)(-\/z,-\/y). Sets the texture M\+I\+N/\+M\+A\+G filter to G\+L\+\_\+\+L\+I\+N\+E\+A\+R\+\_\+\+M\+I\+P\+M\+A\+P\+\_\+\+N\+E\+A\+R\+E\+S\+T/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R if mip maps are present, G\+L\+\_\+\+L\+I\+N\+E\+A\+R/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R otherwise. 

Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{group___a_p_i___o_g_l_e_s3_ga6eecac4c871ba7ccdd0ef4b057a7d596}{\index{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3@{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3}!P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R@{P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R}}
\index{P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R@{P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R}!A\+P\+I\+\_\+\+O\+G\+L\+E\+S3@{A\+P\+I\+\_\+\+O\+G\+L\+E\+S3}}
\subsubsection[{P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R}]{\setlength{\rightskip}{0pt plus 5cm}{\bf E\+P\+V\+R\+T\+Error} P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R (
\begin{DoxyParamCaption}
\item[{const char $\ast$const}]{filename, }
\item[{G\+Luint $\ast$const}]{tex\+Name, }
\item[{const void $\ast$}]{ps\+Texture\+Header, }
\item[{bool}]{b\+Allow\+Decompress, }
\item[{const unsigned int}]{n\+Load\+From\+Level, }
\item[{{\bf C\+P\+V\+R\+T\+Map}$<$ unsigned int, {\bf C\+P\+V\+R\+T\+Map}$<$ unsigned int, {\bf Meta\+Data\+Block} $>$ $>$ $\ast$}]{p\+Meta\+Data}
\end{DoxyParamCaption}
)}}\label{group___a_p_i___o_g_l_e_s3_ga6eecac4c871ba7ccdd0ef4b057a7d596}


Allows textures to be stored in binary P\+V\+R files and loaded in. Can load parts of a mipmaped texture (ie skipping the highest detailed levels). Sets the texture M\+I\+N/\+M\+A\+G filter to G\+L\+\_\+\+L\+I\+N\+E\+A\+R\+\_\+\+M\+I\+P\+M\+A\+P\+\_\+\+N\+E\+A\+R\+E\+S\+T/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R if mipmaps are present, G\+L\+\_\+\+L\+I\+N\+E\+A\+R/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R otherwise. 



 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em filename} & Filename of the .P\+V\+R file to load the texture from \\
\hline
\mbox{\tt in,out}  & {\em tex\+Name} & the Open\+G\+L E\+S texture name as returned by gl\+Bind\+Texture \\
\hline
\mbox{\tt in,out}  & {\em ps\+Texture\+Header} & Pointer to a \hyperlink{struct_p_v_r_texture_header_v3}{P\+V\+R\+Texture\+Header\+V3} struct. Modified to contain the header data of the returned texture Ignored if N\+U\+L\+L. \\
\hline
\mbox{\tt in}  & {\em b\+Allow\+Decompress} & Allow decompression if P\+V\+R\+T\+C is not supported in hardware. \\
\hline
\mbox{\tt in}  & {\em n\+Load\+From\+Level} & Which mipmap level to start loading from (0=all) \\
\hline
\mbox{\tt in,out}  & {\em p\+Meta\+Data} & If a valid map is supplied, this will return any and all Meta\+Data\+Blocks stored in the texture, organised by Dev\+Four\+C\+C then identifier. Supplying N\+U\+L\+L will ignore all Meta\+Data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
P\+V\+R\+\_\+\+S\+U\+C\+C\+E\+S\+S on success
\end{DoxyReturn}


  P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R  filename Filename of the .P\+V\+R file to load the texture from  tex\+Name the Open\+G\+L E\+S texture name as returned by gl\+Bind\+Texture  ps\+Texture\+Header Pointer to a \hyperlink{struct_p_v_r_texture_header_v3}{P\+V\+R\+Texture\+Header\+V3} struct. Modified to contain the header data of the returned texture Ignored if N\+U\+L\+L.  b\+Allow\+Decompress Allow decompression if P\+V\+R\+T\+C is not supported in hardware.  n\+Load\+From\+Level Which mip map level to start loading from (0=all)  p\+Meta\+Data If a valid map is supplied, this will return any and all Meta\+Data\+Blocks stored in the texture, organised by Dev\+Four\+C\+C then identifier. Supplying N\+U\+L\+L will ignore all Meta\+Data.  P\+V\+R\+\_\+\+S\+U\+C\+C\+E\+S\+S on success  Allows textures to be stored in binary P\+V\+R files and loaded in. Can load parts of a mip mapped texture (i.\+e. skipping the highest detailed levels). Sets the texture M\+I\+N/\+M\+A\+G filter to G\+L\+\_\+\+L\+I\+N\+E\+A\+R\+\_\+\+M\+I\+P\+M\+A\+P\+\_\+\+N\+E\+A\+R\+E\+S\+T/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R if mip maps are present, G\+L\+\_\+\+L\+I\+N\+E\+A\+R/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R otherwise.



  P\+V\+R\+T\+Texture\+Load\+From\+P\+V\+R  filename Filename of the .P\+V\+R file to load the texture from  tex\+Name the Open\+G\+L E\+S texture name as returned by gl\+Bind\+Texture  ps\+Texture\+Header Pointer to a \hyperlink{struct_p_v_r___texture___header}{P\+V\+R\+\_\+\+Texture\+\_\+\+Header} struct. Modified to contain the header data of the returned texture Ignored if N\+U\+L\+L.  b\+Allow\+Decompress Allow decompression if P\+V\+R\+T\+C is not supported in hardware.  n\+Load\+From\+Level Which mipmap level to start loading from (0=all)  p\+Meta\+Data If a valid map is supplied, this will return any and all Meta\+Data\+Blocks stored in the texture, organised by Dev\+Four\+C\+C then identifier. Supplying N\+U\+L\+L will ignore all Meta\+Data.  P\+V\+R\+\_\+\+S\+U\+C\+C\+E\+S\+S on success  Allows textures to be stored in binary P\+V\+R files and loaded in. Can load parts of a mipmaped texture (ie skipping the highest detailed levels). Sets the texture M\+I\+N/\+M\+A\+G filter to G\+L\+\_\+\+L\+I\+N\+E\+A\+R\+\_\+\+M\+I\+P\+M\+A\+P\+\_\+\+N\+E\+A\+R\+E\+S\+T/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R if mipmaps are present, G\+L\+\_\+\+L\+I\+N\+E\+A\+R/\+G\+L\+\_\+\+L\+I\+N\+E\+A\+R otherwise. 

Here is the call graph for this function\+:


