\hypertarget{extend_General}{}\section{Overview}\label{extend_General}
Or -\/ how to write your own loaders. It's easy. You just need to implement the \hyperlink{class_assimp_1_1_base_importer}{Assimp\+::\+Base\+Importer} class, which defines a few abstract methods, register your loader, test it carefully and provide test models for it.

O\+K, that sounds too easy \+:-\/). The whole procedure for a new loader merely looks like this\+:


\begin{DoxyItemize}
\item Create a header ({\ttfamily {\itshape Format\+Name}\hyperlink{_importer_8h}{Importer.\+h}}) and a unit ({\ttfamily {\itshape Format\+Name}\hyperlink{_importer_8cpp}{Importer.\+cpp}}) in the {\ttfamily $<$root$>$/code/} directory 
\item Add them to the following workspaces\+: vc8 and vc9 (the files are in the workspaces directory), C\+M\+A\+K\+E (code/\+C\+Make\+Lists.\+txt, create a new source group for your importer and put them also to A\+D\+D\+\_\+\+L\+I\+B\+R\+A\+R\+Y( assimp S\+H\+A\+R\+E\+D)) 
\item Include {\itshape \hyperlink{_assimp_p_c_h_8h}{Assimp\+P\+C\+H.\+h}} -\/ this is the P\+C\+H file, and it includes already most Assimp-\/internal stuff.  
\item Open \hyperlink{_importer_8cpp}{Importer.\+cpp} and include your header just below the {\itshape (include\+\_\+new\+\_\+importers\+\_\+here)} line, guarded by a \#define 
\begin{DoxyCode}
\textcolor{preprocessor}{#if (!defined assimp\_BUILD\_NO\_FormatName\_IMPORTER)}
    ...
#\hyperlink{structendif}{endif}
\end{DoxyCode}
 Wrap the same guard around your .cpp!


\item Now advance to the {\itshape (register\+\_\+new\+\_\+importers\+\_\+here)} line in the \hyperlink{_importer_8cpp}{Importer.\+cpp} and register your importer there -\/ just like all the others do. 
\item Setup a suitable test environment (i.\+e. use \hyperlink{namespace_assimp_view}{Assimp\+View} or your own application), make sure to enable the \hyperlink{postprocess_8h_a64795260b95f5a4b3f3dc1be4f52e410ae420ce22fbbac9d0fd21fd92f2b630fa}{ai\+Process\+\_\+\+Validate\+Data\+Structure} flag and enable verbose logging. That is, simply call before you import anything\+: 
\begin{DoxyCode}
DefaultLogger::create(\textcolor{stringliteral}{"AssimpLog.txt"},Logger::VERBOSE)
\end{DoxyCode}
  
\item Implement the \hyperlink{class_assimp_1_1_base_importer_a13588d3396ba5b7ed1f1cb46e0945cfd}{Assimp\+::\+Base\+Importer\+::\+Can\+Read()}, \hyperlink{class_assimp_1_1_base_importer_ac67d9f5ceb26353d27d6be06cccad398}{Assimp\+::\+Base\+Importer\+::\+Intern\+Read\+File()} and \hyperlink{class_assimp_1_1_base_importer_a7ac75d5fcfe8784173bf117a912bafeb}{Assimp\+::\+Base\+Importer\+::\+Get\+Extension\+List()}. Just copy'n'paste the template from Appendix A and adapt it for your needs.  
\item For error handling, throw a dynamic allocated Import\+Error\+Exception (see Appendix A) for critical errors, and log errors, warnings, infos and debuginfos with Default\+Logger\+::get()-\/$>$\mbox{[}error, warn, debug, info\mbox{]}.  
\item Make sure that your loader compiles against all build configurations on all supported platforms. This includes {\itshape -\/noboost}! To avoid problems, see the boost section on this page for a list of all 'allowed' boost classes (again, this grew historically when we had to accept that boost is not T\+H\+A\+T widely spread that one could rely on it being available everywhere).  
\item Provide some {\itshape free} test models in {\ttfamily $<$root$>$/test/models/$<$Format\+Name$>$/} and credit their authors. \hyperlink{class_test}{Test} files for a file format shouldn't be too large ({\itshape $\sim$500 Ki\+B in total}), and not too repetive. Try to cover all format features with test data.  
\item Done! Please, share your loader that everyone can profit from it!  
\end{DoxyItemize}\hypertarget{extend_properties}{}\section{Properties}\label{extend_properties}
You can use properties to chance the behavior of you importer. In order to do so, you have to overide Base\+Importer\+::\+Setup\+Properties, and specify you custom properties in config.\+h. Just have a look to the other A\+I\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+I\+M\+P\+O\+R\+T\+\_\+$\ast$ defines and you will understand, how it works.

The properties can be set with Importer\+::\+Set\+Property$\ast$$\ast$$\ast$() and can be accessed in your Setup\+Properties function with Importer\+::\+Get\+Property$\ast$$\ast$$\ast$(). You can store the properties as a member variable of your importer, they are thread safe.\hypertarget{extend_tnote}{}\section{Notes for text importers}\label{extend_tnote}

\begin{DoxyItemize}
\item Try to make your parser as flexible as possible. Don't rely on particular layout, whitespace/tab style, except if the file format has a strict definition, in which case you should always warn about spec violations. But the general rule of thumb is {\itshape be strict in what you write and tolerant in what you accept}. 
\item Call \hyperlink{class_assimp_1_1_base_importer_a3cd8c81533de987dd7acea6874ad918c}{Assimp\+::\+Base\+Importer\+::\+Convert\+To\+U\+T\+F8()} before you parse anything to convert foreign encodings to U\+T\+F-\/8. That's not necessary for X\+M\+L importers, which must use the provided Irr\+X\+M\+L for reading.  
\end{DoxyItemize}\hypertarget{extend_bnote}{}\section{Notes for binary importers}\label{extend_bnote}

\begin{DoxyItemize}
\item Take care of endianess issues! \hyperlink{class_assimp}{Assimp} importers mostly support big-\/endian platforms, which define the {\ttfamily A\+I\+\_\+\+B\+U\+I\+L\+D\+\_\+\+B\+I\+G\+\_\+\+E\+N\+D\+I\+A\+N} constant. See the next section for a list of utilities to simplify this task.  
\item Don't trust the input data! Check all offsets!  
\end{DoxyItemize}\hypertarget{extend_util}{}\section{Utilities}\label{extend_util}
Mixed stuff for internal use by loaders, mostly documented (most of them are already included by {\itshape \hyperlink{_assimp_p_c_h_8h}{Assimp\+P\+C\+H.\+h}})\+: 
\begin{DoxyItemize}
\item {\bfseries Byte\+Swap} ({\itshape \hyperlink{_byte_swap_8h_source}{Byte\+Swap.\+h}}) -\/ manual byte swapping stuff for binary loaders. 
\item {\bfseries Stream\+Reader} ({\itshape \hyperlink{_stream_reader_8h_source}{Stream\+Reader.\+h}}) -\/ safe, endianess-\/correct, binary reading. 
\item {\bfseries Irr\+X\+M\+L} ({\itshape \hyperlink{irr_x_m_l_wrapper_8h_source}{irr\+X\+M\+L\+Wrapper.\+h}}) -\/ for X\+M\+L-\/parsing (S\+A\+X. 
\item {\bfseries Comment\+Remover} ({\itshape \hyperlink{_remove_comments_8h_source}{Remove\+Comments.\+h}}) -\/ remove single-\/line and multi-\/line comments from a text file. 
\item fast\+\_\+atof, strtoul10, strtoul16, Skip\+Space\+And\+Line\+End, Skip\+To\+Next\+Token .. large family of low-\/level parsing functions, mostly declared in {\itshape \hyperlink{fast__atof_8h_source}{fast\+\_\+atof.\+h}}, {\itshape \hyperlink{_string_comparison_8h_source}{String\+Comparison.\+h}} and {\itshape \hyperlink{_parsing_utils_8h}{Parsing\+Utils.\+h}} (a collection that grew historically, so don't expect perfect organization).  
\item {\bfseries Compute\+Normals\+With\+Smoothings\+Groups()} ({\itshape \hyperlink{_smoothing_groups_8h_source}{Smoothing\+Groups.\+h}}) -\/ Computes normal vectors from plain old smoothing groups.  
\item {\bfseries Skeleton\+Mesh\+Builder} ({\itshape \hyperlink{_skeleton_mesh_builder_8h}{Skeleton\+Mesh\+Builder.\+h}}) -\/ generate a dummy mesh from a given (animation) skeleton.  
\item {\bfseries Standard\+Shapes} ({\itshape \hyperlink{_standard_shapes_8h_source}{Standard\+Shapes.\+h}}) -\/ generate meshes for standard solids, such as platonic primitives, cylinders or spheres.  
\item {\bfseries Batch\+Loader} ({\itshape \hyperlink{_base_importer_8h_source}{Base\+Importer.\+h}}) -\/ manage imports from external files. Useful for file formats which spread their data across multiple files.  
\item {\bfseries Scene\+Combiner} ({\itshape \hyperlink{_scene_combiner_8h_source}{Scene\+Combiner.\+h}}) -\/ exhaustive toolset to merge multiple scenes. Useful for file formats which spread their data across multiple files.  
\end{DoxyItemize}\hypertarget{extend_mat}{}\section{Filling materials}\label{extend_mat}
The required definitions zo set/remove/query keys in \hyperlink{classai_material}{ai\+Material} structures are declared in {\itshape \hyperlink{_material_system_8h}{Material\+System.\+h}}, in a \hyperlink{classai_material}{ai\+Material} derivate called \hyperlink{classai_material}{ai\+Material}. The header is included by \hyperlink{_assimp_p_c_h_8h}{Assimp\+P\+C\+H.\+h}, so you don't need to bother.


\begin{DoxyCode}
\hyperlink{classai_material}{aiMaterial}* mat = \textcolor{keyword}{new} \hyperlink{classai_material}{aiMaterial}();

\textcolor{keyword}{const} \textcolor{keywordtype}{float} spec = 16.f;
mat->AddProperty(&spec, 1, AI\_MATKEY\_SHININESS);

\textcolor{comment}{//set the name of the material:}
NewMaterial->AddProperty(&\hyperlink{structai_string}{aiString}(MaterialName.c\_str()), AI\_MATKEY\_NAME);\textcolor{comment}{//MaterialName is a
       std::string}

\textcolor{comment}{//set the first diffuse texture}
NewMaterial->AddProperty(&\hyperlink{structai_string}{aiString}(Texturename.c\_str()), 
      \hyperlink{namespaceassimp_1_1material_a267de50d6dfe754f700df9e231ea6b60}{AI\_MATKEY\_TEXTURE}(\hyperlink{material_8h_a7dd415ff703a2cc53d1c22ddbbd7dde0a3027af56603d5babd7e2efcf5ed1debd}{aiTextureType\_DIFFUSE}, 0));\textcolor{comment}{//again, Texturename is
       a std::string}
\end{DoxyCode}
\hypertarget{extend_boost}{}\section{Boost}\label{extend_boost}
The boost whitelist\+: 
\begin{DoxyItemize}
\item {\itshape \hyperlink{classboost_1_1scoped__ptr}{boost.\+scoped\+\_\+ptr}} 
\item {\itshape \hyperlink{classboost_1_1scoped__array}{boost.\+scoped\+\_\+array}} 
\item {\itshape \hyperlink{classboost_1_1format}{boost.\+format}}  
\item {\itshape boost.\+random}  
\item {\itshape boost.\+common\+\_\+factor}  
\item {\itshape boost.\+foreach}  
\item {\itshape \hyperlink{classboost_1_1tuple}{boost.\+tuple}} 
\end{DoxyItemize}

(if you happen to need something else, i.\+e. boost\+::thread, make this an optional feature. {\ttfamily assimp\+\_\+\+B\+U\+I\+L\+D\+\_\+\+B\+O\+O\+S\+T\+\_\+\+W\+O\+R\+K\+A\+R\+O\+U\+N\+D} is defined for {\itshape -\/noboost} builds)\hypertarget{extend_appa}{}\section{Appendix A -\/ Template for Base\+Importer's abstract methods}\label{extend_appa}

\begin{DoxyCode}
\textcolor{comment}{// -------------------------------------------------------------------------------}
\textcolor{comment}{// Returns whether the class can handle the format of the given file. }
\textcolor{keywordtype}{bool} xxxxImporter::CanRead( \textcolor{keyword}{const} std::string& pFile, IOSystem* pIOHandler, 
    \textcolor{keywordtype}{bool} checkSig)\textcolor{keyword}{ const}
\textcolor{keyword}{}\{
    \textcolor{keyword}{const} std::string extension = GetExtension(pFile);
    \textcolor{keywordflow}{if}(extension == \textcolor{stringliteral}{"xxxx"}) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{if} (!extension.length() || checkSig) \{
        \textcolor{comment}{// no extension given, or we're called a second time because no }
        \textcolor{comment}{// suitable loader was found yet. This means, we're trying to open }
        \textcolor{comment}{// the file and look for and hints to identify the file format.}
        \textcolor{comment}{// #Assimp::BaseImporter provides some utilities:}
        \textcolor{comment}{//}
        \textcolor{comment}{// #Assimp::BaseImporter::SearchFileHeaderForToken - for text files.}
        \textcolor{comment}{// It reads the first lines of the file and does a substring check}
        \textcolor{comment}{// against a given list of 'magic' strings.}
        \textcolor{comment}{//}
        \textcolor{comment}{// #Assimp::BaseImporter::CheckMagicToken - for binary files. It goes}
        \textcolor{comment}{// to a particular offset in the file and and compares the next words }
        \textcolor{comment}{// against a given list of 'magic' tokens.}

        \textcolor{comment}{// These checks MUST be done (even if !checkSig) if the file extension }
        \textcolor{comment}{// is not exclusive to your format. For example, .xml is very common }
        \textcolor{comment}{// and (co)used by many formats.}
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
\}

\textcolor{comment}{// -------------------------------------------------------------------------------}
\textcolor{comment}{// Get list of file extensions handled by this loader}
\textcolor{keywordtype}{void} xxxxImporter::GetExtensionList(std::set<std::string>& extensions)
\{
    extensions.insert(\textcolor{stringliteral}{"xxx"});
\}

\textcolor{comment}{// -------------------------------------------------------------------------------}
\textcolor{keywordtype}{void} xxxxImporter::InternReadFile( \textcolor{keyword}{const} std::string& pFile, 
    \hyperlink{structai_scene}{aiScene}* pScene, IOSystem* pIOHandler)
\{
    \hyperlink{classboost_1_1scoped__ptr}{boost::scoped\_ptr<IOStream>} \hyperlink{structfile}{file}( pIOHandler->Open( pFile, \textcolor{stringliteral}{"rb"}));

    \textcolor{comment}{// Check whether we can read from the file}
    \textcolor{keywordflow}{if}( \hyperlink{structfile}{file}.get() == NULL) \{
        \textcolor{keywordflow}{throw} \hyperlink{class_deadly_import_error}{DeadlyImportError}( \textcolor{stringliteral}{"Failed to open xxxx file "} + pFile + \textcolor{stringliteral}{"."});
    \}
    
    \textcolor{comment}{// Your task: fill pScene}
    \textcolor{comment}{// Throw a ImportErrorException with a meaningful (!) error message if }
    \textcolor{comment}{// something goes wrong.}
\}
\end{DoxyCode}
 