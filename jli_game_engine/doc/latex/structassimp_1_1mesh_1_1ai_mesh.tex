\hypertarget{structassimp_1_1mesh_1_1ai_mesh}{\section{assimp\+:\+:mesh\+:\+:ai\+Mesh Struct Reference}
\label{structassimp_1_1mesh_1_1ai_mesh}\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
}


Collaboration diagram for assimp\+:\+:mesh\+:\+:ai\+Mesh\+:
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
uint \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a44f34796ead653c34b9cf15cf2ea3ca4}{m\+Primitive\+Types}
\item 
uint \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a86c33abdd6b7fe4c3a722d5c8c16465a}{m\+Num\+Vertices}
\item 
uint \hyperlink{structassimp_1_1mesh_1_1ai_mesh_af29ef83dde764d0a269a219b61381ab6}{m\+Num\+Faces}
\item 
\hyperlink{structai_vector3_d}{ai\+Vector3\+D} $\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_ae32bf7a3f9169463de97bd33622f8272}{m\+Vertices}
\item 
\hyperlink{structai_vector3_d}{ai\+Vector3\+D} $\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_aee935013afc416792a945b36f7e99d5f}{m\+Normals}
\item 
\hyperlink{structai_vector3_d}{ai\+Vector3\+D} $\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_abd53e75d34cbfc0e3e44768c664def15}{m\+Tangents}
\item 
\hyperlink{structai_vector3_d}{ai\+Vector3\+D} $\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_af4383669a527d07e3d40bfc270d0d882}{m\+Bitangents}
\item 
\hyperlink{structai_color4_d}{ai\+Color4\+D} $\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a66060363bc944adb352801b977b3a102}{m\+Colors} \mbox{[}\hyperlink{namespaceassimp_1_1mesh_a8dd324586aa52f6749c07ddd0ddee1b3}{A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+C\+O\+L\+O\+R\+\_\+\+S\+E\+T\+S}\mbox{]}
\item 
\hyperlink{structai_vector3_d}{ai\+Vector3\+D} $\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a93b9896f1b98b8368cd3c869ea4f2a98}{m\+Texture\+Coords} \mbox{[}\hyperlink{namespaceassimp_1_1mesh_a3a8dfbb9ee6186e1d78d2a8dfa909a10}{A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+C\+O\+O\+R\+D\+S}\mbox{]}
\item 
uint \hyperlink{structassimp_1_1mesh_1_1ai_mesh_aa0fe74d498ea8118b8d628a30b63d4d3}{m\+Num\+U\+V\+Components} \mbox{[}\hyperlink{namespaceassimp_1_1mesh_a3a8dfbb9ee6186e1d78d2a8dfa909a10}{A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+C\+O\+O\+R\+D\+S}\mbox{]}
\item 
\hyperlink{structassimp_1_1mesh_1_1ai_face}{ai\+Face} $\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a522ce4afe9b6e0d0b5df209e620b76ba}{m\+Faces}
\item 
uint \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a18532474ca4579a63506507ab4600c26}{m\+Num\+Bones}
\item 
\hyperlink{structassimp_1_1mesh_1_1ai_bone}{ai\+Bone} $\ast$$\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a5148269d290966a3895593009ef619a0}{m\+Bones}
\item 
uint \hyperlink{structassimp_1_1mesh_1_1ai_mesh_ac5ac01d7d9c915de71c2c80338db9901}{m\+Material\+Index}
\item 
\hyperlink{structassimp_1_1types_1_1ai_string}{ai\+String} \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a3ffa3325c59b7ab92e4743862d47b70f}{m\+Name}
\item 
\hypertarget{structassimp_1_1mesh_1_1ai_mesh_adfa53445525c03a6973e7c8df0c59be5}{uint \hyperlink{structassimp_1_1mesh_1_1ai_mesh_adfa53445525c03a6973e7c8df0c59be5}{m\+Num\+Anim\+Meshes}}\label{structassimp_1_1mesh_1_1ai_mesh_adfa53445525c03a6973e7c8df0c59be5}

\begin{DoxyCompactList}\small\item\em N\+O\+T C\+U\+R\+R\+E\+N\+T\+L\+Y I\+N U\+S\+E. The number of attachment meshes. \end{DoxyCompactList}\item 
\hyperlink{structassimp_1_1mesh_1_1ai_anim_mesh}{ai\+Anim\+Mesh} $\ast$$\ast$ \hyperlink{structassimp_1_1mesh_1_1ai_mesh_a0ef0cdda627aca52178b73ec25d58a82}{m\+Anim\+Meshes}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A mesh represents a geometry or model with a single material.

It usually consists of a number of vertices and a series primitives/faces referencing the vertices. In addition there might be a series of bones, each of them addressing a number of vertices with a certain weight. \hyperlink{struct_vertex}{Vertex} data is presented in channels with each channel containing a single per-\/vertex information such as a set of texture coords or a normal vector. If a data pointer is non-\/null, the corresponding data stream is present.

A mesh uses only a single material which is referenced by a material I\+D.

Note\+: The {\ttfamily m\+Positions} member is usually not optional. However, vertex positions {\itshape could} be missing if the {\ttfamily A\+I\+\_\+\+S\+C\+E\+N\+E\+\_\+\+F\+L\+A\+G\+S\+\_\+\+I\+N\+C\+O\+M\+P\+L\+E\+T\+E} flag is set in {\ttfamily \hyperlink{structai_scene_a4091f10bb81e05db00ebc34f40c48f38}{ai\+Scene.\+m\+Flags}}. 

\subsection{Member Data Documentation}
\hypertarget{structassimp_1_1mesh_1_1ai_mesh_a0ef0cdda627aca52178b73ec25d58a82}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Anim\+Meshes@{m\+Anim\+Meshes}}
\index{m\+Anim\+Meshes@{m\+Anim\+Meshes}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Anim\+Meshes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Anim\+Mesh}$\ast$$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Anim\+Meshes}}\label{structassimp_1_1mesh_1_1ai_mesh_a0ef0cdda627aca52178b73ec25d58a82}
N\+O\+T C\+U\+R\+R\+E\+N\+T\+L\+Y I\+N U\+S\+E. Attachment meshes for this mesh, for vertex-\/ based animation.

Attachment meshes carry replacement data for some of the mesh's vertex components (usually positions, normals). \hypertarget{structassimp_1_1mesh_1_1ai_mesh_af4383669a527d07e3d40bfc270d0d882}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Bitangents@{m\+Bitangents}}
\index{m\+Bitangents@{m\+Bitangents}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Bitangents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Vector3\+D}$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Bitangents}}\label{structassimp_1_1mesh_1_1ai_mesh_af4383669a527d07e3d40bfc270d0d882}
\hyperlink{struct_vertex}{Vertex} bitangents.

The bitangent of a vertex points in the direction of the positive Y texture axis. The array contains normalized vectors, null if not present. The array is {\ttfamily m\+Num\+Vertices} in size.

Note\+: If the mesh contains tangents, it automatically also contains bitangents. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_a5148269d290966a3895593009ef619a0}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Bones@{m\+Bones}}
\index{m\+Bones@{m\+Bones}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Bones}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Bone}$\ast$$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Bones}}\label{structassimp_1_1mesh_1_1ai_mesh_a5148269d290966a3895593009ef619a0}
The bones of this mesh.

A bone consists of a name by which it can be found in the frame hierarchy and a set of vertex weights. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_a66060363bc944adb352801b977b3a102}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Colors@{m\+Colors}}
\index{m\+Colors@{m\+Colors}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Colors}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Color4\+D}$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Colors\mbox{[}{\bf A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+C\+O\+L\+O\+R\+\_\+\+S\+E\+T\+S}\mbox{]}}}\label{structassimp_1_1mesh_1_1ai_mesh_a66060363bc944adb352801b977b3a102}
\hyperlink{struct_vertex}{Vertex} color sets.

A mesh may contain 0 to {\ttfamily A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+C\+O\+L\+O\+R\+\_\+\+S\+E\+T\+S} vertex colors per vertex. null if not present.

Each array is {\ttfamily m\+Num\+Vertices} in size if present. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_a522ce4afe9b6e0d0b5df209e620b76ba}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Faces@{m\+Faces}}
\index{m\+Faces@{m\+Faces}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Faces}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Face}$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Faces}}\label{structassimp_1_1mesh_1_1ai_mesh_a522ce4afe9b6e0d0b5df209e620b76ba}
The faces the mesh is contstructed from.

Each face referrs to a number of vertices by their indices. This array is always present in a mesh, its size is given in {\ttfamily m\+Num\+Faces}. If the {\ttfamily A\+I\+\_\+\+S\+C\+E\+N\+E\+\_\+\+F\+L\+A\+G\+S\+\_\+\+N\+O\+N\+\_\+\+V\+E\+R\+B\+O\+S\+E\+\_\+\+F\+O\+R\+M\+A\+T} is {\itshape not} set, each face references an unique set of vertices. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_ac5ac01d7d9c915de71c2c80338db9901}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Material\+Index@{m\+Material\+Index}}
\index{m\+Material\+Index@{m\+Material\+Index}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Material\+Index}]{\setlength{\rightskip}{0pt plus 5cm}uint assimp\+::mesh\+::ai\+Mesh\+::m\+Material\+Index}}\label{structassimp_1_1mesh_1_1ai_mesh_ac5ac01d7d9c915de71c2c80338db9901}
The material used by this mesh.

A mesh does use only a single material. If an imported model uses multiple materials, the import splits up the mesh. Use this value as index into the scene's material list. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_a3ffa3325c59b7ab92e4743862d47b70f}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Name@{m\+Name}}
\index{m\+Name@{m\+Name}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Name}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+String} assimp\+::mesh\+::ai\+Mesh\+::m\+Name}}\label{structassimp_1_1mesh_1_1ai_mesh_a3ffa3325c59b7ab92e4743862d47b70f}
Name of the mesh.

Meshes can be named, but this is not a requirement and leaving this field empty is totally fine.

There are mainly three uses for mesh names\+:
\begin{DoxyItemize}
\item Some formats name nodes and meshes independently.
\item Importers tend to split meshes up to meet the one-\/material-\/per-\/mesh requirement. Assigning the same (dummy) name to each of the result meshes aids the caller at recovering the original mesh partitioning.
\item \hyperlink{struct_vertex}{Vertex} animations refer to meshes by their names. 
\end{DoxyItemize}\hypertarget{structassimp_1_1mesh_1_1ai_mesh_aee935013afc416792a945b36f7e99d5f}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Normals@{m\+Normals}}
\index{m\+Normals@{m\+Normals}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Normals}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Vector3\+D}$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Normals}}\label{structassimp_1_1mesh_1_1ai_mesh_aee935013afc416792a945b36f7e99d5f}
\hyperlink{struct_vertex}{Vertex} normals.

The array contains normalized vectors, null if not present. The array is {\ttfamily m\+Num\+Vertices} in size.

Normals are undefined for point and line primitives. A mesh consisting of points and lines only may not have normal vectors. Meshes with mixed primitive types (i.\+e. lines and triangles) may have normals, but the normals for vertices that are only referenced by point or line primitives are undefined and set to {\ttfamily Q\+N\+A\+N}.

Note\+: Normal vectors computed by \hyperlink{class_assimp}{Assimp} are always unit-\/length. However, this needn't apply for normals that have been taken directly from the model file. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_a18532474ca4579a63506507ab4600c26}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Num\+Bones@{m\+Num\+Bones}}
\index{m\+Num\+Bones@{m\+Num\+Bones}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Num\+Bones}]{\setlength{\rightskip}{0pt plus 5cm}uint assimp\+::mesh\+::ai\+Mesh\+::m\+Num\+Bones}}\label{structassimp_1_1mesh_1_1ai_mesh_a18532474ca4579a63506507ab4600c26}
The number of bones this mesh contains.

Can be 0, in which case the {\ttfamily m\+Bones} array is null. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_af29ef83dde764d0a269a219b61381ab6}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Num\+Faces@{m\+Num\+Faces}}
\index{m\+Num\+Faces@{m\+Num\+Faces}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Num\+Faces}]{\setlength{\rightskip}{0pt plus 5cm}uint assimp\+::mesh\+::ai\+Mesh\+::m\+Num\+Faces}}\label{structassimp_1_1mesh_1_1ai_mesh_af29ef83dde764d0a269a219b61381ab6}
The number of primitives (triangles, polygons, lines) in this mesh.

This is also the size of the {\ttfamily m\+Faces} array. The maximum value for this member is {\ttfamily A\+I\+\_\+\+M\+A\+X\+\_\+\+F\+A\+C\+E\+S}. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_aa0fe74d498ea8118b8d628a30b63d4d3}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Num\+U\+V\+Components@{m\+Num\+U\+V\+Components}}
\index{m\+Num\+U\+V\+Components@{m\+Num\+U\+V\+Components}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Num\+U\+V\+Components}]{\setlength{\rightskip}{0pt plus 5cm}uint assimp\+::mesh\+::ai\+Mesh\+::m\+Num\+U\+V\+Components\mbox{[}{\bf A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+C\+O\+O\+R\+D\+S}\mbox{]}}}\label{structassimp_1_1mesh_1_1ai_mesh_aa0fe74d498ea8118b8d628a30b63d4d3}
Specifies the number of components for a given U\+V channel.

Up to three channels are supported (U\+V\+W, for accessing volume or cube maps). If the value is 2 for a given channel {\ttfamily n}, the component {\ttfamily p.\+z} of {\ttfamily m\+Texture\+Coords\mbox{[}n\mbox{]}\mbox{[}p\mbox{]}} is set to 0. If the value is 1 for a given channel, {\ttfamily p.\+y} is set to 0, too. If this value is 0, 2 should be assumed.

Note\+: 4\+D coords are not supported. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_a86c33abdd6b7fe4c3a722d5c8c16465a}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Num\+Vertices@{m\+Num\+Vertices}}
\index{m\+Num\+Vertices@{m\+Num\+Vertices}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Num\+Vertices}]{\setlength{\rightskip}{0pt plus 5cm}uint assimp\+::mesh\+::ai\+Mesh\+::m\+Num\+Vertices}}\label{structassimp_1_1mesh_1_1ai_mesh_a86c33abdd6b7fe4c3a722d5c8c16465a}
The number of vertices in this mesh.

This is also the size of all of the per-\/vertex data arrays. The maximum value for this member is {\ttfamily A\+I\+\_\+\+M\+A\+X\+\_\+\+V\+E\+R\+T\+I\+C\+E\+S}. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_a44f34796ead653c34b9cf15cf2ea3ca4}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Primitive\+Types@{m\+Primitive\+Types}}
\index{m\+Primitive\+Types@{m\+Primitive\+Types}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Primitive\+Types}]{\setlength{\rightskip}{0pt plus 5cm}uint assimp\+::mesh\+::ai\+Mesh\+::m\+Primitive\+Types}}\label{structassimp_1_1mesh_1_1ai_mesh_a44f34796ead653c34b9cf15cf2ea3ca4}
Bitwise combination of {\ttfamily ai\+Primitive\+Type} members.

This specifies which types of primitives are present in the mesh. The {\ttfamily Sort\+By\+Primitive\+Type} post processing step can be used to make sure the output meshes consist of one primitive type each. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_abd53e75d34cbfc0e3e44768c664def15}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Tangents@{m\+Tangents}}
\index{m\+Tangents@{m\+Tangents}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Tangents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Vector3\+D}$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Tangents}}\label{structassimp_1_1mesh_1_1ai_mesh_abd53e75d34cbfc0e3e44768c664def15}
\hyperlink{struct_vertex}{Vertex} tangents.

The tangent of a vertex points in the direction of the positive x texture axis. The array contains normalized vectors, null if not present. The array is {\ttfamily m\+Num\+Vertices} in size.

A mesh consisting of points and lines only may not have normal vectors. Meshes with mixed primitive types (i.\+e. lines and triangles) may have normals, but the normals for vertices that are only referenced by point or line primitives are undefined and set to {\ttfamily Q\+N\+A\+N}.

Note\+: If the mesh contains tangents, it automatically also contains bitangents (the bitangent is just the cross product of tangent and normal vectors). \hypertarget{structassimp_1_1mesh_1_1ai_mesh_a93b9896f1b98b8368cd3c869ea4f2a98}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Texture\+Coords@{m\+Texture\+Coords}}
\index{m\+Texture\+Coords@{m\+Texture\+Coords}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Texture\+Coords}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Vector3\+D}$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Texture\+Coords\mbox{[}{\bf A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+C\+O\+O\+R\+D\+S}\mbox{]}}}\label{structassimp_1_1mesh_1_1ai_mesh_a93b9896f1b98b8368cd3c869ea4f2a98}
\hyperlink{struct_vertex}{Vertex} texture coords, also known as U\+V channels. A mesh may contain 0 to {\ttfamily A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+C\+O\+O\+R\+D\+S} per vertex. null if not present.

Each array is {\ttfamily m\+Num\+Vertices} in size. \hypertarget{structassimp_1_1mesh_1_1ai_mesh_ae32bf7a3f9169463de97bd33622f8272}{\index{assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}!m\+Vertices@{m\+Vertices}}
\index{m\+Vertices@{m\+Vertices}!assimp\+::mesh\+::ai\+Mesh@{assimp\+::mesh\+::ai\+Mesh}}
\subsubsection[{m\+Vertices}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ai\+Vector3\+D}$\ast$ assimp\+::mesh\+::ai\+Mesh\+::m\+Vertices}}\label{structassimp_1_1mesh_1_1ai_mesh_ae32bf7a3f9169463de97bd33622f8272}
\hyperlink{struct_vertex}{Vertex} positions.

This array is always present in a mesh. The array is {\ttfamily m\+Num\+Vertices} in size. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
assimp/assimp-\/3.\+1.\+1/port/d\+Assimp/assimp/mesh.\+d\end{DoxyCompactItemize}
