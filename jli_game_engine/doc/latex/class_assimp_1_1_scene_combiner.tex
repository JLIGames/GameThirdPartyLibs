\hypertarget{class_assimp_1_1_scene_combiner}{\section{Assimp\+:\+:Scene\+Combiner Class Reference}
\label{class_assimp_1_1_scene_combiner}\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
}


Static helper class providing various utilities to merge two scenes. It is intended as internal utility and N\+O\+T for use by applications.  




{\ttfamily \#include $<$Scene\+Combiner.\+h$>$}

\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_ad6cdfab1f2b7fba74536f66ead9c5c2b}{Merge\+Scenes} (\hyperlink{structai_scene}{ai\+Scene} $\ast$$\ast$dest, std\+::vector$<$ \hyperlink{structai_scene}{ai\+Scene} $\ast$ $>$ \&src, unsigned int flags=0)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_aa829482d9eecd375cd28cb54b07b98e6}{Merge\+Scenes} (\hyperlink{structai_scene}{ai\+Scene} $\ast$$\ast$dest, \hyperlink{structai_scene}{ai\+Scene} $\ast$master, std\+::vector$<$ \hyperlink{struct_assimp_1_1_attachment_info}{Attachment\+Info} $>$ \&src, unsigned int flags=0)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_a6e29b5f873a22a556cb823de3c118d41}{Merge\+Meshes} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$$\ast$dest, unsigned int flags, std\+::vector$<$ \hyperlink{structai_mesh}{ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator begin, std\+::vector$<$ \hyperlink{structai_mesh}{ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator end)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_a4edb3acefc33160d667f47c045ef6ba8}{Merge\+Bones} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$out, std\+::vector$<$ \hyperlink{structai_mesh}{ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator it, std\+::vector$<$ \hyperlink{structai_mesh}{ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator end)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_ab01dbc7f9794d3cd923eb2b3a398d925}{Merge\+Materials} (\hyperlink{classai_material}{ai\+Material} $\ast$$\ast$dest, std\+::vector$<$ \hyperlink{classai_material}{ai\+Material} $\ast$ $>$\+::const\+\_\+iterator begin, std\+::vector$<$ \hyperlink{classai_material}{ai\+Material} $\ast$ $>$\+::const\+\_\+iterator end)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_a4840646d4e46a1e4c0c56742754dbea3}{Build\+Unique\+Bone\+List} (std\+::list$<$ \hyperlink{struct_assimp_1_1_bone_with_hash}{Bone\+With\+Hash} $>$ \&as\+Bones, std\+::vector$<$ \hyperlink{structai_mesh}{ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator it, std\+::vector$<$ \hyperlink{structai_mesh}{ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator end)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_a0d9ab7d29675eced1a8b5918d908d740}{Add\+Node\+Prefixes} (\hyperlink{structai_node}{ai\+Node} $\ast$node, const char $\ast$prefix, unsigned int len)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_a03b9e3bc5e2d836bae03c87cc69e8359}{Offset\+Node\+Mesh\+Indices} (\hyperlink{structai_node}{ai\+Node} $\ast$node, unsigned int offset)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_a29b11fa0954221fe028f602df4ac732b}{Attach\+To\+Graph} (\hyperlink{structai_scene}{ai\+Scene} $\ast$master, std\+::vector$<$ \hyperlink{struct_assimp_1_1_node_attachment_info}{Node\+Attachment\+Info} $>$ \&src\+List)
\item 
\hypertarget{class_assimp_1_1_scene_combiner_a8d06bd330bf1ccb6374f691bbf22dbe2}{static void {\bfseries Attach\+To\+Graph} (\hyperlink{structai_node}{ai\+Node} $\ast$attach, std\+::vector$<$ \hyperlink{struct_assimp_1_1_node_attachment_info}{Node\+Attachment\+Info} $>$ \&src\+List)}\label{class_assimp_1_1_scene_combiner_a8d06bd330bf1ccb6374f691bbf22dbe2}

\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_a5873036f6b7b81c57857af273ad71c97}{Copy\+Scene} (\hyperlink{structai_scene}{ai\+Scene} $\ast$$\ast$dest, const \hyperlink{structai_scene}{ai\+Scene} $\ast$source, bool allocate=true)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_aa2408f094b4948b4518560862c4a4ec2}{Copy\+Scene\+Flat} (\hyperlink{structai_scene}{ai\+Scene} $\ast$$\ast$dest, const \hyperlink{structai_scene}{ai\+Scene} $\ast$source)
\item 
static void \hyperlink{class_assimp_1_1_scene_combiner_ad78bbac399a4faf44dad90cc81c23312}{Copy} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$$\ast$dest, const \hyperlink{structai_mesh}{ai\+Mesh} $\ast$src)
\item 
\hypertarget{class_assimp_1_1_scene_combiner_a6cb2bd6717879dd09ca1368b71d2aad0}{static void {\bfseries Copy} (\hyperlink{classai_material}{ai\+Material} $\ast$$\ast$dest, const \hyperlink{classai_material}{ai\+Material} $\ast$src)}\label{class_assimp_1_1_scene_combiner_a6cb2bd6717879dd09ca1368b71d2aad0}

\item 
\hypertarget{class_assimp_1_1_scene_combiner_a24c74a29d29291ec2a738b6d7a45943e}{static void {\bfseries Copy} (\hyperlink{structai_texture}{ai\+Texture} $\ast$$\ast$dest, const \hyperlink{structai_texture}{ai\+Texture} $\ast$src)}\label{class_assimp_1_1_scene_combiner_a24c74a29d29291ec2a738b6d7a45943e}

\item 
\hypertarget{class_assimp_1_1_scene_combiner_a56601f1f572286c079855ce282807b70}{static void {\bfseries Copy} (\hyperlink{structai_animation}{ai\+Animation} $\ast$$\ast$dest, const \hyperlink{structai_animation}{ai\+Animation} $\ast$src)}\label{class_assimp_1_1_scene_combiner_a56601f1f572286c079855ce282807b70}

\item 
\hypertarget{class_assimp_1_1_scene_combiner_a5f17cdfb88f986b45a3f7f4e10a7bfe0}{static void {\bfseries Copy} (\hyperlink{structai_camera}{ai\+Camera} $\ast$$\ast$dest, const \hyperlink{structai_camera}{ai\+Camera} $\ast$src)}\label{class_assimp_1_1_scene_combiner_a5f17cdfb88f986b45a3f7f4e10a7bfe0}

\item 
\hypertarget{class_assimp_1_1_scene_combiner_a3c50ee4865c09fc9753fd462b5e50894}{static void {\bfseries Copy} (\hyperlink{structai_bone}{ai\+Bone} $\ast$$\ast$dest, const \hyperlink{structai_bone}{ai\+Bone} $\ast$src)}\label{class_assimp_1_1_scene_combiner_a3c50ee4865c09fc9753fd462b5e50894}

\item 
\hypertarget{class_assimp_1_1_scene_combiner_a35e79f1d364b7e7b91be4f1070e57939}{static void {\bfseries Copy} (\hyperlink{structai_light}{ai\+Light} $\ast$$\ast$dest, const \hyperlink{structai_light}{ai\+Light} $\ast$src)}\label{class_assimp_1_1_scene_combiner_a35e79f1d364b7e7b91be4f1070e57939}

\item 
\hypertarget{class_assimp_1_1_scene_combiner_a2a08144e0a4ac81f2c1afac27847a600}{static void {\bfseries Copy} (\hyperlink{structai_node_anim}{ai\+Node\+Anim} $\ast$$\ast$dest, const \hyperlink{structai_node_anim}{ai\+Node\+Anim} $\ast$src)}\label{class_assimp_1_1_scene_combiner_a2a08144e0a4ac81f2c1afac27847a600}

\item 
\hypertarget{class_assimp_1_1_scene_combiner_a5105586419292aea4ace5ce38e8e90f7}{static void {\bfseries Copy} (\hyperlink{structai_node}{ai\+Node} $\ast$$\ast$dest, const \hyperlink{structai_node}{ai\+Node} $\ast$src)}\label{class_assimp_1_1_scene_combiner_a5105586419292aea4ace5ce38e8e90f7}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Static helper class providing various utilities to merge two scenes. It is intended as internal utility and N\+O\+T for use by applications. 

The class is currently being used by various postprocessing steps and loaders (ie. L\+W\+S). 

\subsection{Member Function Documentation}
\hypertarget{class_assimp_1_1_scene_combiner_a0d9ab7d29675eced1a8b5918d908d740}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Add\+Node\+Prefixes@{Add\+Node\+Prefixes}}
\index{Add\+Node\+Prefixes@{Add\+Node\+Prefixes}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Add\+Node\+Prefixes}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Add\+Node\+Prefixes (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Node} $\ast$}]{node, }
\item[{const char $\ast$}]{prefix, }
\item[{unsigned int}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_a0d9ab7d29675eced1a8b5918d908d740}
Add a name prefix to all nodes in a scene.


\begin{DoxyParams}{Parameters}
{\em Current} & node. This function is called recursively. \\
\hline
{\em prefix} & Prefix to be added to all nodes \\
\hline
{\em len} & S\+Tring length \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_a29b11fa0954221fe028f602df4ac732b}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Attach\+To\+Graph@{Attach\+To\+Graph}}
\index{Attach\+To\+Graph@{Attach\+To\+Graph}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Attach\+To\+Graph}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Attach\+To\+Graph (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Scene} $\ast$}]{master, }
\item[{std\+::vector$<$ {\bf Node\+Attachment\+Info} $>$ \&}]{src\+List}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_a29b11fa0954221fe028f602df4ac732b}
Attach a list of node graphs to well-\/defined nodes in a master graph. This is a helper for \hyperlink{class_assimp_1_1_scene_combiner_ad6cdfab1f2b7fba74536f66ead9c5c2b}{Merge\+Scenes()}


\begin{DoxyParams}{Parameters}
{\em master} & Master scene \\
\hline
{\em src\+List} & List of source scenes along with their attachment points. If an attachment point is N\+U\+L\+L (or does not exist in the master graph), a scene is attached to the root of the master graph (as an additional child node)  List of duplicates. If elem\mbox{[}n\mbox{]} == n the scene is not a duplicate. Otherwise elem\mbox{[}n\mbox{]} links scene n to its first occurence. \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_a4840646d4e46a1e4c0c56742754dbea3}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Build\+Unique\+Bone\+List@{Build\+Unique\+Bone\+List}}
\index{Build\+Unique\+Bone\+List@{Build\+Unique\+Bone\+List}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Build\+Unique\+Bone\+List}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Build\+Unique\+Bone\+List (
\begin{DoxyParamCaption}
\item[{std\+::list$<$ {\bf Bone\+With\+Hash} $>$ \&}]{as\+Bones, }
\item[{std\+::vector$<$ {\bf ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator}]{it, }
\item[{std\+::vector$<$ {\bf ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator}]{end}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_a4840646d4e46a1e4c0c56742754dbea3}
Builds a list of uniquely named bones in a mesh list


\begin{DoxyParams}{Parameters}
{\em as\+Bones} & Receives the output list \\
\hline
{\em it} & First mesh to be processed \\
\hline
{\em end} & Last mesh to be processed \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_ad78bbac399a4faf44dad90cc81c23312}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Copy@{Copy}}
\index{Copy@{Copy}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Copy}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Copy (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Mesh} $\ast$$\ast$}]{dest, }
\item[{const {\bf ai\+Mesh} $\ast$}]{src}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_ad78bbac399a4faf44dad90cc81c23312}
Get a deep copy of a mesh


\begin{DoxyParams}{Parameters}
{\em dest} & Receives a pointer to the destination mesh \\
\hline
{\em src} & Source mesh -\/ remains unmodified. \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_a5873036f6b7b81c57857af273ad71c97}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Copy\+Scene@{Copy\+Scene}}
\index{Copy\+Scene@{Copy\+Scene}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Copy\+Scene}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Copy\+Scene (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Scene} $\ast$$\ast$}]{dest, }
\item[{const {\bf ai\+Scene} $\ast$}]{source, }
\item[{bool}]{allocate = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_a5873036f6b7b81c57857af273ad71c97}
Get a deep copy of a scene


\begin{DoxyParams}{Parameters}
{\em dest} & Receives a pointer to the destination scene \\
\hline
{\em src} & Source scene -\/ remains unmodified. \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_aa2408f094b4948b4518560862c4a4ec2}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Copy\+Scene\+Flat@{Copy\+Scene\+Flat}}
\index{Copy\+Scene\+Flat@{Copy\+Scene\+Flat}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Copy\+Scene\+Flat}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Copy\+Scene\+Flat (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Scene} $\ast$$\ast$}]{dest, }
\item[{const {\bf ai\+Scene} $\ast$}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_aa2408f094b4948b4518560862c4a4ec2}
Get a flat copy of a scene

Only the first hierarchy layer is copied. All pointer members of \hyperlink{structai_scene}{ai\+Scene} are shared by source and destination scene. If the pointer doesn't point to N\+U\+L\+L when the function is called, the existing scene is cleared and refilled. 
\begin{DoxyParams}{Parameters}
{\em dest} & Receives a pointer to the destination scene \\
\hline
{\em src} & Source scene -\/ remains unmodified. \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_a4edb3acefc33160d667f47c045ef6ba8}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Merge\+Bones@{Merge\+Bones}}
\index{Merge\+Bones@{Merge\+Bones}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Merge\+Bones}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Merge\+Bones (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Mesh} $\ast$}]{out, }
\item[{std\+::vector$<$ {\bf ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator}]{it, }
\item[{std\+::vector$<$ {\bf ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator}]{end}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_a4edb3acefc33160d667f47c045ef6ba8}
Merges two or more bones


\begin{DoxyParams}{Parameters}
{\em out} & \hyperlink{class_mesh}{Mesh} to receive the output bone list \\
\hline
{\em flags} & Currently no parameters \\
\hline
{\em begin} & First mesh to be processed \\
\hline
{\em end} & Points to the mesh after the last mesh to be processed \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_ab01dbc7f9794d3cd923eb2b3a398d925}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Merge\+Materials@{Merge\+Materials}}
\index{Merge\+Materials@{Merge\+Materials}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Merge\+Materials}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Merge\+Materials (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Material} $\ast$$\ast$}]{dest, }
\item[{std\+::vector$<$ {\bf ai\+Material} $\ast$ $>$\+::const\+\_\+iterator}]{begin, }
\item[{std\+::vector$<$ {\bf ai\+Material} $\ast$ $>$\+::const\+\_\+iterator}]{end}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_ab01dbc7f9794d3cd923eb2b3a398d925}
Merges two or more materials

The materials should be complementary as much as possible. In case of a property present in different materials, the first occurence is used.


\begin{DoxyParams}{Parameters}
{\em dest} & Destination material. Must be empty. \\
\hline
{\em begin} & First material to be processed \\
\hline
{\em end} & Points to the material after the last material to be processed \\
\hline
\end{DoxyParams}
\hypertarget{class_assimp_1_1_scene_combiner_a6e29b5f873a22a556cb823de3c118d41}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Merge\+Meshes@{Merge\+Meshes}}
\index{Merge\+Meshes@{Merge\+Meshes}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Merge\+Meshes}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Merge\+Meshes (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Mesh} $\ast$$\ast$}]{dest, }
\item[{unsigned int}]{flags, }
\item[{std\+::vector$<$ {\bf ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator}]{begin, }
\item[{std\+::vector$<$ {\bf ai\+Mesh} $\ast$ $>$\+::const\+\_\+iterator}]{end}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_a6e29b5f873a22a556cb823de3c118d41}
Merges two or more meshes

The meshes should have equal vertex formats. Only components that are provided by A\+L\+L meshes will be present in the output mesh. An exception is made for V\+Colors -\/ they are set to black. The meshes should have the same material indices, too. The output material index is always the material index of the first mesh.


\begin{DoxyParams}{Parameters}
{\em dest} & Destination mesh. Must be empty. \\
\hline
{\em flags} & Currently no parameters \\
\hline
{\em begin} & First mesh to be processed \\
\hline
{\em end} & Points to the mesh after the last mesh to be processed \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_ad6cdfab1f2b7fba74536f66ead9c5c2b}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Merge\+Scenes@{Merge\+Scenes}}
\index{Merge\+Scenes@{Merge\+Scenes}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Merge\+Scenes}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Merge\+Scenes (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Scene} $\ast$$\ast$}]{dest, }
\item[{std\+::vector$<$ {\bf ai\+Scene} $\ast$ $>$ \&}]{src, }
\item[{unsigned int}]{flags = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_ad6cdfab1f2b7fba74536f66ead9c5c2b}
Merges two or more scenes.


\begin{DoxyParams}{Parameters}
{\em dest} & Receives a pointer to the destination scene. If the pointer doesn't point to N\+U\+L\+L when the function is called, the existing scene is cleared and refilled. \\
\hline
{\em src} & Non-\/empty list of scenes to be merged. The function deletes the input scenes afterwards. There may be duplicate scenes. \\
\hline
{\em flags} & Combination of the A\+I\+\_\+\+I\+N\+T\+\_\+\+M\+E\+R\+G\+E\+\_\+\+S\+C\+E\+N\+E flags defined above \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:




Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_aa829482d9eecd375cd28cb54b07b98e6}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Merge\+Scenes@{Merge\+Scenes}}
\index{Merge\+Scenes@{Merge\+Scenes}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Merge\+Scenes}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Merge\+Scenes (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Scene} $\ast$$\ast$}]{dest, }
\item[{{\bf ai\+Scene} $\ast$}]{master, }
\item[{std\+::vector$<$ {\bf Attachment\+Info} $>$ \&}]{src, }
\item[{unsigned int}]{flags = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_aa829482d9eecd375cd28cb54b07b98e6}
Merges two or more scenes and attaches all sceenes to a specific position in the node graph of the masteer scene.


\begin{DoxyParams}{Parameters}
{\em dest} & Receives a pointer to the destination scene. If the pointer doesn't point to N\+U\+L\+L when the function is called, the existing scene is cleared and refilled. \\
\hline
{\em master} & Master scene. It will be deleted afterwards. All other scenes will be inserted in its node graph. \\
\hline
{\em src} & Non-\/empty list of scenes to be merged along with their corresponding attachment points in the master scene. The function deletes the input scenes afterwards. There may be duplicate scenes. \\
\hline
{\em flags} & Combination of the A\+I\+\_\+\+I\+N\+T\+\_\+\+M\+E\+R\+G\+E\+\_\+\+S\+C\+E\+N\+E flags defined above \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:


\hypertarget{class_assimp_1_1_scene_combiner_a03b9e3bc5e2d836bae03c87cc69e8359}{\index{Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}!Offset\+Node\+Mesh\+Indices@{Offset\+Node\+Mesh\+Indices}}
\index{Offset\+Node\+Mesh\+Indices@{Offset\+Node\+Mesh\+Indices}!Assimp\+::\+Scene\+Combiner@{Assimp\+::\+Scene\+Combiner}}
\subsubsection[{Offset\+Node\+Mesh\+Indices}]{\setlength{\rightskip}{0pt plus 5cm}void Assimp\+::\+Scene\+Combiner\+::\+Offset\+Node\+Mesh\+Indices (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Node} $\ast$}]{node, }
\item[{unsigned int}]{offset}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_scene_combiner_a03b9e3bc5e2d836bae03c87cc69e8359}
Add an offset to all mesh indices in a node graph


\begin{DoxyParams}{Parameters}
{\em Current} & node. This function is called recursively. \\
\hline
{\em offset} & Offset to be added to all mesh indices \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
assimp/assimp-\/3.\+1.\+1/code/Scene\+Combiner.\+h\item 
assimp/assimp-\/3.\+1.\+1/code/Scene\+Combiner.\+cpp\end{DoxyCompactItemize}
