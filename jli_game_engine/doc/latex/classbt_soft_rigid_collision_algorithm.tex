\hypertarget{classbt_soft_rigid_collision_algorithm}{\section{bt\+Soft\+Rigid\+Collision\+Algorithm Class Reference}
\label{classbt_soft_rigid_collision_algorithm}\index{bt\+Soft\+Rigid\+Collision\+Algorithm@{bt\+Soft\+Rigid\+Collision\+Algorithm}}
}


\hyperlink{classbt_soft_rigid_collision_algorithm}{bt\+Soft\+Rigid\+Collision\+Algorithm} provides collision detection between \hyperlink{classbt_soft_body}{bt\+Soft\+Body} and \hyperlink{classbt_rigid_body}{bt\+Rigid\+Body}  




{\ttfamily \#include $<$bt\+Soft\+Rigid\+Collision\+Algorithm.\+h$>$}



Inheritance diagram for bt\+Soft\+Rigid\+Collision\+Algorithm\+:


Collaboration diagram for bt\+Soft\+Rigid\+Collision\+Algorithm\+:
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structbt_soft_rigid_collision_algorithm_1_1_create_func}{Create\+Func}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classbt_soft_rigid_collision_algorithm_aa6f289e315d626acf0a47ba093f6d4eb}{bt\+Soft\+Rigid\+Collision\+Algorithm} (bt\+Persistent\+Manifold $\ast$mf, const \hyperlink{structbt_collision_algorithm_construction_info}{bt\+Collision\+Algorithm\+Construction\+Info} \&ci, const \hyperlink{structbt_collision_object_wrapper}{bt\+Collision\+Object\+Wrapper} $\ast$col0, const \hyperlink{structbt_collision_object_wrapper}{bt\+Collision\+Object\+Wrapper} $\ast$col1\+Wrap, bool is\+Swapped)
\item 
\hypertarget{classbt_soft_rigid_collision_algorithm_ae2a70ed305793bc69865ca0ae21d4b31}{virtual void {\bfseries process\+Collision} (const \hyperlink{structbt_collision_object_wrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body0\+Wrap, const \hyperlink{structbt_collision_object_wrapper}{bt\+Collision\+Object\+Wrapper} $\ast$body1\+Wrap, const \hyperlink{structbt_dispatcher_info}{bt\+Dispatcher\+Info} \&dispatch\+Info, \hyperlink{classbt_manifold_result}{bt\+Manifold\+Result} $\ast$result\+Out)}\label{classbt_soft_rigid_collision_algorithm_ae2a70ed305793bc69865ca0ae21d4b31}

\item 
\hypertarget{classbt_soft_rigid_collision_algorithm_a81633f06daef836f73903d787ee71b67}{virtual bt\+Scalar {\bfseries calculate\+Time\+Of\+Impact} (bt\+Collision\+Object $\ast$body0, bt\+Collision\+Object $\ast$body1, const \hyperlink{structbt_dispatcher_info}{bt\+Dispatcher\+Info} \&dispatch\+Info, \hyperlink{classbt_manifold_result}{bt\+Manifold\+Result} $\ast$result\+Out)}\label{classbt_soft_rigid_collision_algorithm_a81633f06daef836f73903d787ee71b67}

\item 
\hypertarget{classbt_soft_rigid_collision_algorithm_a09c0bea1a9c7ee41ac9f67287f581f89}{virtual void {\bfseries get\+All\+Contact\+Manifolds} (\hyperlink{classbt_aligned_object_array}{bt\+Manifold\+Array} \&manifold\+Array)}\label{classbt_soft_rigid_collision_algorithm_a09c0bea1a9c7ee41ac9f67287f581f89}

\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\hyperlink{classbt_soft_rigid_collision_algorithm}{bt\+Soft\+Rigid\+Collision\+Algorithm} provides collision detection between \hyperlink{classbt_soft_body}{bt\+Soft\+Body} and \hyperlink{classbt_rigid_body}{bt\+Rigid\+Body} 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classbt_soft_rigid_collision_algorithm_aa6f289e315d626acf0a47ba093f6d4eb}{\index{bt\+Soft\+Rigid\+Collision\+Algorithm@{bt\+Soft\+Rigid\+Collision\+Algorithm}!bt\+Soft\+Rigid\+Collision\+Algorithm@{bt\+Soft\+Rigid\+Collision\+Algorithm}}
\index{bt\+Soft\+Rigid\+Collision\+Algorithm@{bt\+Soft\+Rigid\+Collision\+Algorithm}!bt\+Soft\+Rigid\+Collision\+Algorithm@{bt\+Soft\+Rigid\+Collision\+Algorithm}}
\subsubsection[{bt\+Soft\+Rigid\+Collision\+Algorithm}]{\setlength{\rightskip}{0pt plus 5cm}bt\+Soft\+Rigid\+Collision\+Algorithm\+::bt\+Soft\+Rigid\+Collision\+Algorithm (
\begin{DoxyParamCaption}
\item[{bt\+Persistent\+Manifold $\ast$}]{mf, }
\item[{const {\bf bt\+Collision\+Algorithm\+Construction\+Info} \&}]{ci, }
\item[{const {\bf bt\+Collision\+Object\+Wrapper} $\ast$}]{col0, }
\item[{const {\bf bt\+Collision\+Object\+Wrapper} $\ast$}]{col1\+Wrap, }
\item[{bool}]{is\+Swapped}
\end{DoxyParamCaption}
)}}\label{classbt_soft_rigid_collision_algorithm_aa6f289e315d626acf0a47ba093f6d4eb}
T\+O\+D\+O\+: include all the shapes that the softbody can collide with alternatively, implement special case collision algorithms (just like for rigid collision shapes) 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
bullet/bullet-\/2.\+82-\/r2704/src/\+Bullet\+Soft\+Body/bt\+Soft\+Rigid\+Collision\+Algorithm.\+h\item 
bullet/bullet-\/2.\+82-\/r2704/src/\+Bullet\+Soft\+Body/bt\+Soft\+Rigid\+Collision\+Algorithm.\+cpp\end{DoxyCompactItemize}
