\hypertarget{class_assimp_1_1_subdivider}{\section{Assimp\+:\+:Subdivider Class Reference}
\label{class_assimp_1_1_subdivider}\index{Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}}
}


{\ttfamily \#include $<$Subdivision.\+h$>$}



Inheritance diagram for Assimp\+:\+:Subdivider\+:
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{class_assimp_1_1_subdivider_a5e6b4948d6aaee509e58fb435ad02b9d}{Algorithm} \{ {\bfseries C\+A\+T\+M\+U\+L\+L\+\_\+\+C\+L\+A\+R\+K\+E} = 0x1
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{class_assimp_1_1_subdivider_a4598b3ead068ae7f49bce239e33ee325}{Subdivide} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$mesh, \hyperlink{structai_mesh}{ai\+Mesh} $\ast$\&out, unsigned int num, bool discard\+\_\+input=false)=0
\item 
virtual void \hyperlink{class_assimp_1_1_subdivider_a26a77d10069201eb198942c8b7459f0f}{Subdivide} (\hyperlink{structai_mesh}{ai\+Mesh} $\ast$$\ast$smesh, size\+\_\+t nmesh, \hyperlink{structai_mesh}{ai\+Mesh} $\ast$$\ast$out, unsigned int num, bool discard\+\_\+input=false)=0
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{class_assimp_1_1_subdivider}{Subdivider} $\ast$ \hyperlink{class_assimp_1_1_subdivider_a167b67d07cbc0342b02f476f5825cdd4}{Create} (\hyperlink{class_assimp_1_1_subdivider_a5e6b4948d6aaee509e58fb435ad02b9d}{Algorithm} algo)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Helper class to evaluate subdivision surfaces. Different algorithms are provided for choice. 

\subsection{Member Enumeration Documentation}
\hypertarget{class_assimp_1_1_subdivider_a5e6b4948d6aaee509e58fb435ad02b9d}{\index{Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}!Algorithm@{Algorithm}}
\index{Algorithm@{Algorithm}!Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}}
\subsubsection[{Algorithm}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Assimp\+::\+Subdivider\+::\+Algorithm}}}\label{class_assimp_1_1_subdivider_a5e6b4948d6aaee509e58fb435ad02b9d}
Enumerates all supported subvidision algorithms 

\subsection{Member Function Documentation}
\hypertarget{class_assimp_1_1_subdivider_a167b67d07cbc0342b02f476f5825cdd4}{\index{Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}!Create@{Create}}
\index{Create@{Create}!Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}}
\subsubsection[{Create}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Subdivider} $\ast$ Subdivider\+::\+Create (
\begin{DoxyParamCaption}
\item[{{\bf Algorithm}}]{algo}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{class_assimp_1_1_subdivider_a167b67d07cbc0342b02f476f5825cdd4}
Create a subdivider of a specific type


\begin{DoxyParams}{Parameters}
{\em algo} & Algorithm to be used for subdivision \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{class_assimp_1_1_subdivider}{Subdivider} instance. 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_subdivider_a4598b3ead068ae7f49bce239e33ee325}{\index{Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}!Subdivide@{Subdivide}}
\index{Subdivide@{Subdivide}!Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}}
\subsubsection[{Subdivide}]{\setlength{\rightskip}{0pt plus 5cm}virtual void Assimp\+::\+Subdivider\+::\+Subdivide (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Mesh} $\ast$}]{mesh, }
\item[{{\bf ai\+Mesh} $\ast$\&}]{out, }
\item[{unsigned int}]{num, }
\item[{bool}]{discard\+\_\+input = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}}\label{class_assimp_1_1_subdivider_a4598b3ead068ae7f49bce239e33ee325}
Subdivide a mesh using the selected algorithm


\begin{DoxyParams}{Parameters}
{\em mesh} & First mesh to be subdivided. Must be in verbose format. \\
\hline
{\em out} & Receives the output mesh, allocated by me. \\
\hline
{\em num} & Number of subdivisions to perform. \\
\hline
{\em discard\+\_\+input} & If true is passed, the input mesh is deleted after the subdivision is complete. This can improve performance because it allows the optimization to reuse the existing mesh for intermediate results. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
out!=mesh 
\end{DoxyPrecond}


Implemented in \hyperlink{class_catmull_clark_subdivider_a3626843e8b19de31fd44d94487132c12}{Catmull\+Clark\+Subdivider}.



Here is the caller graph for this function\+:


\hypertarget{class_assimp_1_1_subdivider_a26a77d10069201eb198942c8b7459f0f}{\index{Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}!Subdivide@{Subdivide}}
\index{Subdivide@{Subdivide}!Assimp\+::\+Subdivider@{Assimp\+::\+Subdivider}}
\subsubsection[{Subdivide}]{\setlength{\rightskip}{0pt plus 5cm}virtual void Assimp\+::\+Subdivider\+::\+Subdivide (
\begin{DoxyParamCaption}
\item[{{\bf ai\+Mesh} $\ast$$\ast$}]{smesh, }
\item[{size\+\_\+t}]{nmesh, }
\item[{{\bf ai\+Mesh} $\ast$$\ast$}]{out, }
\item[{unsigned int}]{num, }
\item[{bool}]{discard\+\_\+input = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}}\label{class_assimp_1_1_subdivider_a26a77d10069201eb198942c8b7459f0f}
Subdivide multiple meshes using the selected algorithm. This avoids erroneous smoothing on objects consisting of multiple per-\/material meshes. Usually, most 3d modellers smooth on a per-\/object base, regardless the materials assigned to the meshes.


\begin{DoxyParams}{Parameters}
{\em smesh} & Array of meshes to be subdivided. Must be in verbose format. \\
\hline
{\em nmesh} & Number of meshes in smesh. \\
\hline
{\em out} & Receives the output meshes. The array must be sufficiently large (at least {\ttfamily nmesh} elements) and may not overlap the input array. Output meshes map one-\/to-\/one to their corresponding input meshes. The meshes are allocated by the function. \\
\hline
{\em discard\+\_\+input} & If true is passed, input meshes are deleted after the subdivision is complete. This can improve performance because it allows the optimization of reusing existing meshes for intermediate results. \\
\hline
{\em num} & Number of subdivisions to perform. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
nmesh != 0, smesh and out may not overlap 
\end{DoxyPrecond}


Implemented in \hyperlink{class_catmull_clark_subdivider_a26357a64f91c069d1b99d61fe98d15bf}{Catmull\+Clark\+Subdivider}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
assimp/assimp-\/3.\+1.\+1/code/Subdivision.\+h\item 
assimp/assimp-\/3.\+1.\+1/code/Subdivision.\+cpp\end{DoxyCompactItemize}
