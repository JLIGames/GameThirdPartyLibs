\hypertarget{classirr_1_1core_1_1array}{\section{irr\+:\+:core\+:\+:array$<$ T $>$ Class Template Reference}
\label{classirr_1_1core_1_1array}\index{irr\+::core\+::array$<$ T $>$@{irr\+::core\+::array$<$ T $>$}}
}


Self reallocating template array (like stl vector) with additional features.  




{\ttfamily \#include $<$irr\+Array.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classirr_1_1core_1_1array_acdf3e210bef431b4b789d616c6048b56}{array} (u32 start\+\_\+count)
\item 
\hypertarget{classirr_1_1core_1_1array_addc7b26c37e43024be3240344ef7ae4b}{\hyperlink{classirr_1_1core_1_1array_addc7b26c37e43024be3240344ef7ae4b}{array} (const \hyperlink{classirr_1_1core_1_1array}{array}$<$ T $>$ \&other)}\label{classirr_1_1core_1_1array_addc7b26c37e43024be3240344ef7ae4b}

\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1array_a66774d7073dfe9794c1190b4a9fee73c}{$\sim$array} ()
\item 
void \hyperlink{classirr_1_1core_1_1array_a1fa222a8692a1e2da94bc7e86b75cdae}{reallocate} (u32 new\+\_\+size)
\item 
void \hyperlink{classirr_1_1core_1_1array_a95afc36513d08abb51bd399755730877}{push\+\_\+back} (const T \&element)
\item 
void \hyperlink{classirr_1_1core_1_1array_a27ce37ef9e34e55d4f9987c62deda9d6}{push\+\_\+front} (const T \&element)
\item 
void \hyperlink{classirr_1_1core_1_1array_a7dd91405226e52db0c5a26add9f8e106}{insert} (const T \&element, u32 index=0)
\item 
\hypertarget{classirr_1_1core_1_1array_a611c70809111b608a103f86e004d6eb7}{void \hyperlink{classirr_1_1core_1_1array_a611c70809111b608a103f86e004d6eb7}{clear} ()}\label{classirr_1_1core_1_1array_a611c70809111b608a103f86e004d6eb7}

\begin{DoxyCompactList}\small\item\em Clears the array and deletes all allocated memory. \end{DoxyCompactList}\item 
void \hyperlink{classirr_1_1core_1_1array_ad0efa8d2ea5078580e5cea1848992a88}{set\+\_\+pointer} (T $\ast$new\+Pointer, u32 \hyperlink{classirr_1_1core_1_1array_ad63ccc83da39943532c7af164c7b7bcf}{size})
\item 
void \hyperlink{classirr_1_1core_1_1array_a0b66cac31609933337fb81bb4a518c8c}{set\+\_\+free\+\_\+when\+\_\+destroyed} (bool f)
\item 
void \hyperlink{classirr_1_1core_1_1array_a0767f2095c59d44a73abf4a9fa9480ba}{set\+\_\+used} (u32 used\+Now)
\item 
\hypertarget{classirr_1_1core_1_1array_aa0f0ea56d18bb90eb5c8f286c7273a88}{void \hyperlink{classirr_1_1core_1_1array_aa0f0ea56d18bb90eb5c8f286c7273a88}{operator=} (const \hyperlink{classirr_1_1core_1_1array}{array}$<$ T $>$ \&other)}\label{classirr_1_1core_1_1array_aa0f0ea56d18bb90eb5c8f286c7273a88}

\begin{DoxyCompactList}\small\item\em Assignement operator. \end{DoxyCompactList}\item 
\hypertarget{classirr_1_1core_1_1array_a67098e889f4e1f72e442f17dd50cff5f}{T \& \hyperlink{classirr_1_1core_1_1array_a67098e889f4e1f72e442f17dd50cff5f}{operator\mbox{[}$\,$\mbox{]}} (u32 index)}\label{classirr_1_1core_1_1array_a67098e889f4e1f72e442f17dd50cff5f}

\begin{DoxyCompactList}\small\item\em Direct access operator. \end{DoxyCompactList}\item 
\hypertarget{classirr_1_1core_1_1array_adb02c1c24954863613a6f2ab0f316bf2}{const T \& \hyperlink{classirr_1_1core_1_1array_adb02c1c24954863613a6f2ab0f316bf2}{operator\mbox{[}$\,$\mbox{]}} (u32 index) const }\label{classirr_1_1core_1_1array_adb02c1c24954863613a6f2ab0f316bf2}

\begin{DoxyCompactList}\small\item\em Direct access operator. \end{DoxyCompactList}\item 
\hypertarget{classirr_1_1core_1_1array_a5424fdabc6ad12f503a15b2c4d7f6b0e}{const T \& \hyperlink{classirr_1_1core_1_1array_a5424fdabc6ad12f503a15b2c4d7f6b0e}{get\+Last} () const }\label{classirr_1_1core_1_1array_a5424fdabc6ad12f503a15b2c4d7f6b0e}

\begin{DoxyCompactList}\small\item\em Gets last frame. \end{DoxyCompactList}\item 
\hypertarget{classirr_1_1core_1_1array_a142e1833faabec2b7578557fd12e72c2}{T \& \hyperlink{classirr_1_1core_1_1array_a142e1833faabec2b7578557fd12e72c2}{get\+Last} ()}\label{classirr_1_1core_1_1array_a142e1833faabec2b7578557fd12e72c2}

\begin{DoxyCompactList}\small\item\em Gets last frame. \end{DoxyCompactList}\item 
T $\ast$ \hyperlink{classirr_1_1core_1_1array_afe5fd668b288ea14a585144c62d99c03}{pointer} ()
\item 
const T $\ast$ \hyperlink{classirr_1_1core_1_1array_abf62c8ec9581f618a4412721568b349e}{const\+\_\+pointer} () const 
\item 
u32 \hyperlink{classirr_1_1core_1_1array_ad63ccc83da39943532c7af164c7b7bcf}{size} () const 
\item 
u32 \hyperlink{classirr_1_1core_1_1array_a3291d7ce05c97ce6acf794f53718df63}{allocated\+\_\+size} () const 
\item 
bool \hyperlink{classirr_1_1core_1_1array_a80b1c057a23ab3d3ca84db8737659943}{empty} () const 
\item 
void \hyperlink{classirr_1_1core_1_1array_ad25908968e87d8c6a43f36a7143bc10b}{sort} ()
\item 
s32 \hyperlink{classirr_1_1core_1_1array_a225b3bcb55293f18b90e069a979e44c6}{binary\+\_\+search} (const T \&element)
\item 
s32 \hyperlink{classirr_1_1core_1_1array_a995506f4a479910947ebbf74a939aed4}{binary\+\_\+search} (const T \&element, s32 left, s32 right)
\item 
s32 \hyperlink{classirr_1_1core_1_1array_a917e0d2690b9871d2d13d9ec0a3626f5}{linear\+\_\+search} (T \&element)
\item 
s32 \hyperlink{classirr_1_1core_1_1array_a4efb7d86fc42e6b29e932f983d6ffae0}{linear\+\_\+reverse\+\_\+search} (T \&element)
\item 
void \hyperlink{classirr_1_1core_1_1array_aa28ffba81d9af68bdc76fb2df1e10428}{erase} (u32 index)
\item 
void \hyperlink{classirr_1_1core_1_1array_a2b749c99e727919254f1f0593fbd30ed}{erase} (u32 index, s32 count)
\item 
\hypertarget{classirr_1_1core_1_1array_a5322149d943e3a5b23dff3000f825a01}{void \hyperlink{classirr_1_1core_1_1array_a5322149d943e3a5b23dff3000f825a01}{set\+\_\+sorted} (bool \+\_\+is\+\_\+sorted)}\label{classirr_1_1core_1_1array_a5322149d943e3a5b23dff3000f825a01}

\begin{DoxyCompactList}\small\item\em Sets if the array is sorted. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class T$>$class irr\+::core\+::array$<$ T $>$}

Self reallocating template array (like stl vector) with additional features. 

Some features are\+: Heap sorting, binary search methods, easier debugging. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classirr_1_1core_1_1array_acdf3e210bef431b4b789d616c6048b56}{\index{irr\+::core\+::array@{irr\+::core\+::array}!array@{array}}
\index{array@{array}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{array}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf irr\+::core\+::array}$<$ T $>$\+::{\bf array} (
\begin{DoxyParamCaption}
\item[{u32}]{start\+\_\+count}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_acdf3e210bef431b4b789d616c6048b56}
Constructs a array and allocates an initial chunk of memory. 
\begin{DoxyParams}{Parameters}
{\em start\+\_\+count} & Amount of elements to allocate. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_a66774d7073dfe9794c1190b4a9fee73c}{\index{irr\+::core\+::array@{irr\+::core\+::array}!````~array@{$\sim$array}}
\index{````~array@{$\sim$array}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{$\sim$array}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf irr\+::core\+::array}$<$ T $>$\+::$\sim${\bf array} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a66774d7073dfe9794c1190b4a9fee73c}
Destructor. Frees allocated memory, if set\+\_\+free\+\_\+when\+\_\+destroyed was not set to false by the user before. 

\subsection{Member Function Documentation}
\hypertarget{classirr_1_1core_1_1array_a3291d7ce05c97ce6acf794f53718df63}{\index{irr\+::core\+::array@{irr\+::core\+::array}!allocated\+\_\+size@{allocated\+\_\+size}}
\index{allocated\+\_\+size@{allocated\+\_\+size}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{allocated\+\_\+size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ u32 {\bf irr\+::core\+::array}$<$ T $>$\+::allocated\+\_\+size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a3291d7ce05c97ce6acf794f53718df63}
Returns amount memory allocated. \begin{DoxyReturn}{Returns}
Returns amount of memory allocated. The amount of bytes allocated would be \hyperlink{classirr_1_1core_1_1array_a3291d7ce05c97ce6acf794f53718df63}{allocated\+\_\+size()} $\ast$ sizeof(\+Elements\+Used); 
\end{DoxyReturn}
\hypertarget{classirr_1_1core_1_1array_a225b3bcb55293f18b90e069a979e44c6}{\index{irr\+::core\+::array@{irr\+::core\+::array}!binary\+\_\+search@{binary\+\_\+search}}
\index{binary\+\_\+search@{binary\+\_\+search}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{binary\+\_\+search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ s32 {\bf irr\+::core\+::array}$<$ T $>$\+::binary\+\_\+search (
\begin{DoxyParamCaption}
\item[{const T \&}]{element}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a225b3bcb55293f18b90e069a979e44c6}
Performs a binary search for an element, returns -\/1 if not found. The array will be sorted before the binary search if it is not already sorted. 
\begin{DoxyParams}{Parameters}
{\em element} & Element to search for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns position of the searched element if it was found, otherwise -\/1 is returned. 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{classirr_1_1core_1_1array_a995506f4a479910947ebbf74a939aed4}{\index{irr\+::core\+::array@{irr\+::core\+::array}!binary\+\_\+search@{binary\+\_\+search}}
\index{binary\+\_\+search@{binary\+\_\+search}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{binary\+\_\+search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ s32 {\bf irr\+::core\+::array}$<$ T $>$\+::binary\+\_\+search (
\begin{DoxyParamCaption}
\item[{const T \&}]{element, }
\item[{s32}]{left, }
\item[{s32}]{right}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a995506f4a479910947ebbf74a939aed4}
Performs a binary search for an element, returns -\/1 if not found. The array will be sorted before the binary search if it is not already sorted. 
\begin{DoxyParams}{Parameters}
{\em element} & Element to search for. \\
\hline
{\em left} & First left index \\
\hline
{\em right} & Last right index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns position of the searched element if it was found, otherwise -\/1 is returned. 
\end{DoxyReturn}
\hypertarget{classirr_1_1core_1_1array_abf62c8ec9581f618a4412721568b349e}{\index{irr\+::core\+::array@{irr\+::core\+::array}!const\+\_\+pointer@{const\+\_\+pointer}}
\index{const\+\_\+pointer@{const\+\_\+pointer}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{const\+\_\+pointer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ const T$\ast$ {\bf irr\+::core\+::array}$<$ T $>$\+::const\+\_\+pointer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_abf62c8ec9581f618a4412721568b349e}
Returns a const pointer to the array. \begin{DoxyReturn}{Returns}
Pointer to the array. 
\end{DoxyReturn}
\hypertarget{classirr_1_1core_1_1array_a80b1c057a23ab3d3ca84db8737659943}{\index{irr\+::core\+::array@{irr\+::core\+::array}!empty@{empty}}
\index{empty@{empty}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{empty}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ bool {\bf irr\+::core\+::array}$<$ T $>$\+::empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a80b1c057a23ab3d3ca84db8737659943}
Returns true if array is empty \begin{DoxyReturn}{Returns}
True if the array is empty, false if not. 
\end{DoxyReturn}
\hypertarget{classirr_1_1core_1_1array_aa28ffba81d9af68bdc76fb2df1e10428}{\index{irr\+::core\+::array@{irr\+::core\+::array}!erase@{erase}}
\index{erase@{erase}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{erase}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::erase (
\begin{DoxyParamCaption}
\item[{u32}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_aa28ffba81d9af68bdc76fb2df1e10428}
Erases an element from the array. May be slow, because all elements following after the erased element have to be copied. 
\begin{DoxyParams}{Parameters}
{\em index} & \hyperlink{struct_index}{Index} of element to be erased. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_a2b749c99e727919254f1f0593fbd30ed}{\index{irr\+::core\+::array@{irr\+::core\+::array}!erase@{erase}}
\index{erase@{erase}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{erase}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::erase (
\begin{DoxyParamCaption}
\item[{u32}]{index, }
\item[{s32}]{count}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a2b749c99e727919254f1f0593fbd30ed}
Erases some elements from the array. may be slow, because all elements following after the erased element have to be copied. 
\begin{DoxyParams}{Parameters}
{\em index} & \hyperlink{struct_index}{Index} of the first element to be erased. \\
\hline
{\em count} & Amount of elements to be erased. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_a7dd91405226e52db0c5a26add9f8e106}{\index{irr\+::core\+::array@{irr\+::core\+::array}!insert@{insert}}
\index{insert@{insert}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::insert (
\begin{DoxyParamCaption}
\item[{const T \&}]{element, }
\item[{u32}]{index = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a7dd91405226e52db0c5a26add9f8e106}
Insert item into array at specified position. Please use this only if you know what you are doing (possible performance loss). The preferred method of adding elements should be \hyperlink{classirr_1_1core_1_1array_a95afc36513d08abb51bd399755730877}{push\+\_\+back()}. 
\begin{DoxyParams}{Parameters}
{\em element} & Element to be inserted \\
\hline
{\em index} & Where position to insert the new element. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_a4efb7d86fc42e6b29e932f983d6ffae0}{\index{irr\+::core\+::array@{irr\+::core\+::array}!linear\+\_\+reverse\+\_\+search@{linear\+\_\+reverse\+\_\+search}}
\index{linear\+\_\+reverse\+\_\+search@{linear\+\_\+reverse\+\_\+search}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{linear\+\_\+reverse\+\_\+search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ s32 {\bf irr\+::core\+::array}$<$ T $>$\+::linear\+\_\+reverse\+\_\+search (
\begin{DoxyParamCaption}
\item[{T \&}]{element}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a4efb7d86fc42e6b29e932f983d6ffae0}
Finds an element in linear time, which is very slow. Use binary\+\_\+search for faster finding. Only works if =operator is implemented. 
\begin{DoxyParams}{Parameters}
{\em element} & Element to search for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns position of the searched element if it was found, otherwise -\/1 is returned. 
\end{DoxyReturn}
\hypertarget{classirr_1_1core_1_1array_a917e0d2690b9871d2d13d9ec0a3626f5}{\index{irr\+::core\+::array@{irr\+::core\+::array}!linear\+\_\+search@{linear\+\_\+search}}
\index{linear\+\_\+search@{linear\+\_\+search}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{linear\+\_\+search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ s32 {\bf irr\+::core\+::array}$<$ T $>$\+::linear\+\_\+search (
\begin{DoxyParamCaption}
\item[{T \&}]{element}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a917e0d2690b9871d2d13d9ec0a3626f5}
Finds an element in linear time, which is very slow. Use binary\+\_\+search for faster finding. Only works if =operator is implemented. 
\begin{DoxyParams}{Parameters}
{\em element} & Element to search for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns position of the searched element if it was found, otherwise -\/1 is returned. 
\end{DoxyReturn}
\hypertarget{classirr_1_1core_1_1array_afe5fd668b288ea14a585144c62d99c03}{\index{irr\+::core\+::array@{irr\+::core\+::array}!pointer@{pointer}}
\index{pointer@{pointer}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{pointer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ T$\ast$ {\bf irr\+::core\+::array}$<$ T $>$\+::pointer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_afe5fd668b288ea14a585144c62d99c03}
Returns a pointer to the array. \begin{DoxyReturn}{Returns}
Pointer to the array. 
\end{DoxyReturn}
\hypertarget{classirr_1_1core_1_1array_a95afc36513d08abb51bd399755730877}{\index{irr\+::core\+::array@{irr\+::core\+::array}!push\+\_\+back@{push\+\_\+back}}
\index{push\+\_\+back@{push\+\_\+back}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{push\+\_\+back}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::push\+\_\+back (
\begin{DoxyParamCaption}
\item[{const T \&}]{element}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a95afc36513d08abb51bd399755730877}
Adds an element at back of array. If the array is to small to add this new element, the array is made bigger. 
\begin{DoxyParams}{Parameters}
{\em element} & Element to add at the back of the array. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_a27ce37ef9e34e55d4f9987c62deda9d6}{\index{irr\+::core\+::array@{irr\+::core\+::array}!push\+\_\+front@{push\+\_\+front}}
\index{push\+\_\+front@{push\+\_\+front}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{push\+\_\+front}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::push\+\_\+front (
\begin{DoxyParamCaption}
\item[{const T \&}]{element}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a27ce37ef9e34e55d4f9987c62deda9d6}
Adds an element at the front of the array. If the array is to small to add this new element, the array is made bigger. Please note that this is slow, because the whole array needs to be copied for this. 
\begin{DoxyParams}{Parameters}
{\em element} & Element to add at the back of the array. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_a1fa222a8692a1e2da94bc7e86b75cdae}{\index{irr\+::core\+::array@{irr\+::core\+::array}!reallocate@{reallocate}}
\index{reallocate@{reallocate}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{reallocate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::reallocate (
\begin{DoxyParamCaption}
\item[{u32}]{new\+\_\+size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a1fa222a8692a1e2da94bc7e86b75cdae}
Reallocates the array, make it bigger or smaller. 
\begin{DoxyParams}{Parameters}
{\em new\+\_\+size} & New size of array. \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:


\hypertarget{classirr_1_1core_1_1array_a0b66cac31609933337fb81bb4a518c8c}{\index{irr\+::core\+::array@{irr\+::core\+::array}!set\+\_\+free\+\_\+when\+\_\+destroyed@{set\+\_\+free\+\_\+when\+\_\+destroyed}}
\index{set\+\_\+free\+\_\+when\+\_\+destroyed@{set\+\_\+free\+\_\+when\+\_\+destroyed}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{set\+\_\+free\+\_\+when\+\_\+destroyed}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::set\+\_\+free\+\_\+when\+\_\+destroyed (
\begin{DoxyParamCaption}
\item[{bool}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a0b66cac31609933337fb81bb4a518c8c}
Sets if the array should delete the memory it used. 
\begin{DoxyParams}{Parameters}
{\em f} & If true, the array frees the allocated memory in its destructor, otherwise not. The default is true. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_ad0efa8d2ea5078580e5cea1848992a88}{\index{irr\+::core\+::array@{irr\+::core\+::array}!set\+\_\+pointer@{set\+\_\+pointer}}
\index{set\+\_\+pointer@{set\+\_\+pointer}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{set\+\_\+pointer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::set\+\_\+pointer (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{new\+Pointer, }
\item[{u32}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_ad0efa8d2ea5078580e5cea1848992a88}
Sets pointer to new array, using this as new workspace. 
\begin{DoxyParams}{Parameters}
{\em new\+Pointer} & Pointer to new array of elements. \\
\hline
{\em size} & Size of the new array. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_a0767f2095c59d44a73abf4a9fa9480ba}{\index{irr\+::core\+::array@{irr\+::core\+::array}!set\+\_\+used@{set\+\_\+used}}
\index{set\+\_\+used@{set\+\_\+used}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{set\+\_\+used}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::set\+\_\+used (
\begin{DoxyParamCaption}
\item[{u32}]{used\+Now}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_a0767f2095c59d44a73abf4a9fa9480ba}
Sets the size of the array. 
\begin{DoxyParams}{Parameters}
{\em used\+Now} & Amount of elements now used. \\
\hline
\end{DoxyParams}
\hypertarget{classirr_1_1core_1_1array_ad63ccc83da39943532c7af164c7b7bcf}{\index{irr\+::core\+::array@{irr\+::core\+::array}!size@{size}}
\index{size@{size}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ u32 {\bf irr\+::core\+::array}$<$ T $>$\+::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_ad63ccc83da39943532c7af164c7b7bcf}
Returns size of used array. \begin{DoxyReturn}{Returns}
Size of elements in the array. 
\end{DoxyReturn}


Here is the caller graph for this function\+:


\hypertarget{classirr_1_1core_1_1array_ad25908968e87d8c6a43f36a7143bc10b}{\index{irr\+::core\+::array@{irr\+::core\+::array}!sort@{sort}}
\index{sort@{sort}!irr\+::core\+::array@{irr\+::core\+::array}}
\subsubsection[{sort}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::array}$<$ T $>$\+::sort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classirr_1_1core_1_1array_ad25908968e87d8c6a43f36a7143bc10b}
Sorts the array using heapsort. There is no additional memory waste and the algorithm performs (O) n log n in worst case. 

Here is the caller graph for this function\+:




The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
assimp/assimp-\/3.\+1.\+1/contrib/irr\+X\+M\+L/irr\+Array.\+h\end{DoxyCompactItemize}
